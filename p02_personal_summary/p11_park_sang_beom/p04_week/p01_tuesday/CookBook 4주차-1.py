'''
--------------------------------------------------------------------------------------
5.14 파일 이름 인코딩 우회

문제 : 시스템의 기본 인코딩으로 디코딩 혹은 인코딩되지 않은 파일 이름에 입출력 작업 수행하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 기본적으로 모든 파일 이름은 sys.getfilesystemencoding() 이 반환하는 텍스트 인코딩 값으로 디코딩 혹은 인코딩되어 있다
--------------------------------------------------------------------------------------
'''

import sys

print(sys.getfilesystemencoding())

'''
--------------------------------------------------------------------------------------
- 위 인코딩을 우회하길 바란다면 로우(raw) 바이트 문자열로 파일 이름 명시!
--------------------------------------------------------------------------------------
'''

# 유니코드로 파일이름 쓰기
with open('e:\data\somefile.txt', 'w') as f:
    f.write('Spicy!')

# 디렉터리 리스트(디코딩됨)
import os

print(os.listdir('.'))

# 디렉터리 리스트(디코딩되지 않음)
import os

print(os.listdir(b'.'))

# 로우 파일 이름으로 파일 열기
with open(b'e:\data\somefile.txt') as f:
    print(f.read())

'''
=> open() 이나 os.listdir() 와 같은 파일 관련 함수에 바이트 문자열을 넣었을때 파일 이름 처리는 거의 변하지 않는다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.15 망가진 파일 이름 출력

문제 : 프로그램에서 디렉터리 리스트를 받아 파일 이름을 출력하려고 할때 UnicodeEncodeError 예외와
      surrogates not allowed 메시지가 발생하면서 프로그램이 죽어 버린다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 출처를 알 수 없는 파일 이름을 출력할 때, 다음 코드로 에러 방지
--------------------------------------------------------------------------------------
'''

def bad_filename(filename):
    try:
        print(filename)

    except UnicodeEncodeError:
        print(bad_filename(filename))

    return repr(filename)[1:-1]

'''
--------------------------------------------------------------------------------------
- os.listdir() 와 같은 명령을 실행할 때, 망가진 파일 이름을 사용하면 파이썬에 문제가 생긴다

- 위 해결책으로 디코딩할 수 없는 바이트 값 \xhh 를 Unicode 문자 \udchh 로 표현하는 소위
  대리 인코딩(surrogate encoding) 으로 매핑하는 것
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- UTF-8 이 아닌 Latin-1 으로 인코딩한 bad.txt 를 포함한 디렉터리 리스트가가 어떻게 보이는지 예제 코드
--------------------------------------------------------------------------------------
'''

import os

files = os.listdir('.')

print(files)

'''
--------------------------------------------------------------------------------------
- 특히 선행 리스트를 출력하려고 하면 프로그램이 비정상적으로 종료
  프로그램이 죽는 이유는 \udce4가 잘못된 Unicode 이기 때문이다
  
- 대리 짝(surrogate pair) 으로 알려진 문자 두 개의 조합
  하지만 첫 번째 반쪽이 없기 때문에 올바른 Unicode라 할 수 없다
  따라서 올바른 출력을 하려면 망가진 파일 이름을 발견했을 때 교정 작업 필요!
--------------------------------------------------------------------------------------
'''

for name in files:
    try:
        print(name)
    except UnicodeEncodeError:
        print(bad_filename(name))

'''
--------------------------------------------------------------------------------------
- bad_filename() 함수 를 이용해 재인코딩 코드
--------------------------------------------------------------------------------------
'''

def bad_filename(filename):
    temp = filename.encode(sys.getfilesystemencoding(), errors='surrogateescape')
    return temp.decode('latin-1')

for name in files:
    try:
        print(name)
    except UnicodeEncodeError:
        print(bad_filename(name))





'''
--------------------------------------------------------------------------------------
5.16 이미 열려 있는 파일의 인코딩을 수정하거나 추가하기

문제 : 이미 열려 있는 파일을 닫지 않고 Unicode 인코딩을 추가하거나 변경하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 바이너리 모드로 이미 열려 있는 파일 객체를 닫지 않고 Unicode 인코딩/디코딩을 추가하고 싶다면
  그 객체를 io.TextIOWrapper() 객체로 감싼다
--------------------------------------------------------------------------------------
'''

import urllib.request
import io

u = urllib.request.urlopen('http://www.python.org')
f = io.TextIOWrapper(u,encoding='utf-8')

text = f.read()

'''
--------------------------------------------------------------------------------------
- 텍스트 모드로 열린 파일의 인코딩을 변경하려면 detach() 메소드로 텍스트 인코딩 레이터를 제거하고
  다른 것으로 치환 (sys.stdout 의 인코딩 바꾸는 방법)
--------------------------------------------------------------------------------------
'''

import sys

print(sys.stdout.encoding)

sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding='latin-1')

print(sys.stdout.encoding)


f = open('e:/data/somefile.txt','w')

print(f)
print(f.buffer)
print(f.buffer.raw)





'''
--------------------------------------------------------------------------------------
5.17 텍스트 파일에 바이트 쓰기

문제 : 텍스트 모드로 연 파일에 로우 바이트 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 단순히 바이트 데이터를 buffer 에 쓰기 
--------------------------------------------------------------------------------------
'''

import sys

# sys.stdout.write(b'Hello\n')

print(sys.stdout.buffer.write(b'Hello\n'))

'''
=> 위와 유사하게 텍스트 파일의 buffer 속성에서 바이너리 데이터를 읽을 수도 있다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- I/O 시스템은 레이어로부터 만들어진다
  텍스트 파일은 버퍼 바이너리 모드 파일 상단에 Unicode 인코딩/디코딩 레이러를 추가해서 생성된다
  buffer 속성은 바로 이 파일 아래 부분을 가리킨다
  여기에 접근하면 텍스트 인코딩/디코딩 레이어를 우회할 수 있다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.18 기존 파일 디스크립터를 파일 객체로 감싸기

문제 : 운영 체제 상에 이미 열려 있는 I/O 채널에 일치하는 정수형 파일 디스크립터를 가지고 있고
      (file, pipe, socket 등) 이를 상위 레벨 파이썬 파일 객체로 감싸기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 파일 디스크립터가 있을 때 open() 함수를 사용해 파이썬 파일 객체로 감쌀 수 있다
  하지만 이때 파일 이름 대신 정수형 파일 디스크립터를 먼저 전달해야 한다
--------------------------------------------------------------------------------------
'''

# 하위 레벨 파일 디스크립터 열기
import os

fd = os.open('e:/data/somefile.txt', os.O_WRONLY | os.O_CREAT)

# 올바른 파일로 바꾸기
f = open(fd, 'wt')
f.write('hello world\n')
f.close()

'''
--------------------------------------------------------------------------------------
- 상위 레벨 파일 객체가 닫혔거나 파괴되었다면 그 하단 파일 스크립터 역시 닫힌다
  이런 동작을 원하지 않는다면 closefd=False 인자를 open() 에 전달 
--------------------------------------------------------------------------------------
'''

import os

fd = os.open('e:/data/somefile.txt', os.O_WRONLY | os.O_CREAT)
f = open(fd, 'wt', closefd=False)

'''
--------------------------------------------------------------------------------------
- 소켓과 관련된 예제 코드
--------------------------------------------------------------------------------------
'''

from socket import socket, AF_INET, SOCK_STREAM

def echo_client(client_sock, addr):
    print('Got connection from', addr)

    # 읽기/쓰기를 위해 소켓에 대한 텍스트 모드 파일 래퍼(Wrapper)를 만든다
    client_in = open(client_sock.fileno(), 'rt', encoding='latin-1',closefd=False)
    client_out = open(client_sock.fileno(), 'wt', encoding='latin-1',closefd=False)

    # 파일 I/O를 사용해 클라이언트에 라인을 에코한다
    for line in client_in:
        client_out.write(line)
        client_out.flush()
    client_sock.close()

def echo_server(address):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(address)
    sock.listen(1)
    while True:
        client, addr = sock.accept()
        echo_client(client, addr)

'''
=> 소켓에 대한 파일 같은 인터페이스가 필요하고 크로스 플랫폼 코드가 필요하다면 소켓의 makefile() 메소드 사용
   하지만 이식성을 신경쓰지 않는다면 makefile()을 사용하는 것보다 앞에 나온 예제가 더 성능면에서 훨씬 뛰어나다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- stdout(일반적으로 텍스트 모드로 열려 있다)에 바이너리 데이터를 넣기 위한 파일 객체를 만드는 코드
--------------------------------------------------------------------------------------
'''

import sys

# studot에 대한 바이너리 모드 파일 만들기
bstdout = open(sys.stdout.fileno(), 'wb', closefd=False)
bstdout.write(b'Hello World\n')
bstdout.flush()

'''
=> 기존 파일 디스크립터를 파일로 감싸는 것도 가능하지만, 모든 파일 모드를 지원하지 않을 수 있고 이런 파일 디스크립터에
   예상치 못한 부작용이 생길 수 있다(에러 처리, 파일 끝 찾기 등에서 특히 위험하다)
   또한 동작성이 운영 체제에 따라 달라지기도 한다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.19 임시 파일 디렉터리 만들기

문제 : 임시 파일이나 디렉터리를 만들어 프로그램에 사용해야 한다
      그 후에 파일이나 디렉터리는 아마도 파기할 생각이다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- tempfile 모듈에 이런 목적의 함수가 많이 있다
  이름 없는 임시 파일을 만들기 위해서 tempfile.TemporaryFile 사용
--------------------------------------------------------------------------------------
'''

from tempfile import TemporaryFile

with TemporaryFile('w+t') as f:
    f.write('Hello World\n')
    f.write('Testing\n')

    # 처음으로 이동해 데이터를 읽는다
    f.seek(0)
    data = f.read()

# 다음과 같이 파일을 사용할 수도 있다
# 임시 파일 사용
f = TemporaryFile('w+t')

# ...

# 파일 파기
f.colse()

'''
--------------------------------------------------------------------------------------
- TemporaryFile()에 전달하는 첫 번째 인자는 파일 모드이고, 텍스트 모드에는 대개 w+t를,
  바이너리 모드에는 w+b를 사용, 이 모드는 읽기와 쓰기를 동시에 지원하기 때문에 모드 변경을 위해
  파일을 닫으면 실제로 파기하므로 유용
  
- TemporaryFile()은 추가적으로 내장 함수 open()과 동일한 인자를 받는다
--------------------------------------------------------------------------------------
'''

with TemporaryFile('w+t', encoding='utf-8', errors='ignore') as f:
    ...

'''
--------------------------------------------------------------------------------------
- 대게 Unix 시스템에서 TemporaryFile()로 생성한 파일에 이름이 없고 디렉터리 엔트리도 갖지 않는다
  이 제한을 없애고 싶으면 NamedTempoaryFile() 을 사용
--------------------------------------------------------------------------------------
'''

from tempfile import NamedTemporaryFile

with NamedTemporaryFile('w+t') as f:
    print('filename is:', f.name)

'''
--------------------------------------------------------------------------------------
- f.name 속성에 임시 파일의 이름이 담겨있다. 다른 코드에 이 파일을 전달해야 할 필요가 생겼을 때 이 속성을 유용하게 사용

- TempoaryFile() 과 마찬가지로 생성된 파일의 사용이 끝났을 때 자동으로 삭제된다
  이런 동작을 원하지 않는다면 delete=False 키워드 인자 사용
--------------------------------------------------------------------------------------
'''

from tempfile import NamedTemporaryFile

with NamedTemporaryFile('w+t', delete=False) as f:
    print('filename is:', f.name)

'''
--------------------------------------------------------------------------------------
- 임시 디렉터리를 만들기 위해서는 tempfile.TemporaryDiretory() 사용
--------------------------------------------------------------------------------------
'''

from tempfile import TemporaryDirectory

with TemporaryDirectory() as dirname:
    print('dirname is : ', dirname)

'''
--------------------------------------------------------------------------------------
- 임시 파일과 디렉터리를 만들 때 TemporaryFile(), NamedTemporaryFile(), TemporaryDirectory() 함수가 가장 쉬운 방법
  이 함수는 생성과 추후 파기까지 모두 자동으로 처리
  
- 더 하위 레벨로 내려가면 mkstemp() 와 mkdtemp() 로 임시파일과 디렉터리를 만들 수 있다
--------------------------------------------------------------------------------------
'''

import tempfile

tempfile.mkstemp()

# 실제 위치를 찾으려면 tempfile.gettempdir() 함수 사용
tempfile.gettempdir()

# 모든 임시 파일 관련 함수는 디렉터리와 이름 규칙을 오버라이드할 수 있도록 하는데
# perfix, suffix, dir 키워드 사용

f = NamedTemporaryFile(prefix='mytemp', suffix='.txt', dir='/tmp')
f.name






'''
--------------------------------------------------------------------------------------
Chapter 6 데이터 인코딩과 프로세싱
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
6.1 CSV 데이터 읽고 쓰기

문제 : CSV 파일로 인코딩된 데이터를 읽거나 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 대부분의 CSV 데이터는 csv 라이브러리 사용
  데이터를 읽어 튜플 시퀀스에 넣을 수 있는 코드 
--------------------------------------------------------------------------------------
'''

import csv

with open('e:\data\glass.csv') as f:
    f_csv = csv.reader(f)
    headers = next(f_csv)
    for row in f_csv:
        print(row)

'''
=> 위 코드에서 row는 튜플이 된다
   따라서 특정 필드에 접근하려면 row[0](symbol), row[4](change) 와 같이 인덱스 사용
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 인덱스 사용이 때때로 헷갈리기 때문에 네임드 튜플 사용 
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

with open('e:\data\glass.csv') as f:
    f_csv = csv.reader(f)
    headings = next(f_csv)
    Row = namedtuple('Row', headings)
    for r in f_csv:
        row = Row(*r)
        print(row)

'''
--------------------------------------------------------------------------------------
- 데이터를 딕셔너리 시퀀스로 읽기
--------------------------------------------------------------------------------------
'''

import csv

with open('e:\data\glass.csv') as f:
    f_csv = csv.DictReader(f)
    for row in f_csv:
        print(row)

'''
--------------------------------------------------------------------------------------
- CSV 데이터 쓰기
--------------------------------------------------------------------------------------
'''

import csv

headers = ['Symbol', 'Price', 'Date', 'Time', 'Change', 'Volume']
rows = [('AA', 39.48, '6/11/2007', '9:36am', -0.18, 181800),
        ('AIG', 71.38, '6/11/2007', '9:36am', -0.15, 195500),
        ('AXP', 62.58, '6/11/2007', '9:36am', -0.46, 935000)]

with open('e:\data\sample.csv','w') as f:
    f_csv = csv.writer(f)
    f_csv.writerow(headers)
    f_csv.writerows(rows)

'''
--------------------------------------------------------------------------------------
- 데이터를 딕셔너리 시퀀스로 가지고 있을 때 CSV 데이터 쓰기
--------------------------------------------------------------------------------------
'''

import csv

headers = ['Symbol', 'Price', 'Date', 'Time', 'Change', 'Volume']
rows = [{'Symbol':'AA', 'Price':39.48, 'Date':'6/11/2007',
         'Time':'9:36am', 'Change':-0.18, 'Volume':181800},
        {'Symbol':'AIG', 'Price': 71.38, 'Date':'6/11/2007',
         'Time':'9:36am', 'Change':-0.15, 'Volume': 195500},
        {'Symbol':'AXP', 'Price': 62.58, 'Date':'6/11/2007',
         'Time':'9:36am', 'Change':-0.46, 'Volume': 935000}]

with open('e:\data\sample.csv','w') as f:
    f_csv = csv.DictWriter(f, headers)
    f_csv.writeheader()
    f_csv.writerows(rows)

'''
--------------------------------------------------------------------------------------
- 탭으로 구분된 값 읽기
--------------------------------------------------------------------------------------
'''

import csv

with open('e:\data\sample.csv') as f:
    f_csv = csv.reader(f, delimiter='\t')
    for row in f_csv:
        print(row)

'''
--------------------------------------------------------------------------------------
- 정규 표현식을 사용해서 유효하지 않은 문자를 치환
--------------------------------------------------------------------------------------
'''

import re

with open('e:\data\sample.csv') as f:
    f_csv = csv.reader(f)
    headers = [re.sub('[^a-zA-Z_]', '_', h) for h in next(f_csv)]
    Row = namedtuple('Row', headers)
    for r in f_csv:
        row = Row(*r)
        print(row)

'''
--------------------------------------------------------------------------------------
- CSV 데이터에 대해서 추가적인 형식 변환
--------------------------------------------------------------------------------------
'''

import csv

col_types = ['Symbol', 'Price',	'Date',	'Time',	'Change	Volume']

with open('e:/data/sample.csv') as f:
    f_csv = csv.reader(f)
    headers = next(f_csv)
    for row in f_csv:
        row = tuple(convert(value) for convert, value in zip(col_types, row))
        print(row)

'''
--------------------------------------------------------------------------------------
- 딕셔너리에서 선택한 필드만 변환
--------------------------------------------------------------------------------------
'''

import csv

print('Reading as dicts with type conversion')

field_types = [('Price', float),
               ('Change', float),
               ('Volume', int)]

with open('e:/data/sample.csv') as f:
    for row in csv.DictReader(f):
        row.update((key, conversion(row[key]))
                   for key, conversion in field_types)
        print(row)





'''
--------------------------------------------------------------------------------------
6.2 JSON 데이터 읽고 쓰기

문제 : JSON(JavaScript Object Notation) 으로 인코딩된 데이터 읽거나 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- JSON으로 데이터를 인코딩, 디코딩하는 쉬운 방법은 json 모듈 사용
  
- 주요 함수는 json.dumps(), json.loads(), pickle 과 같은 직렬화 라이브러리에서 사용한 것과 인터페이스는 동일
--------------------------------------------------------------------------------------
'''

import json

data = {'name' : 'ACME', 'shares' : 100, 'price' : 542.23}
json_str = json.dumps(data)

print(json_str)

'''
--------------------------------------------------------------------------------------
- JSON 인코딩된 문자열을 파이썬 자료 구조로 돌리는 코드
--------------------------------------------------------------------------------------
'''

data = json.loads(json_str)

'''
--------------------------------------------------------------------------------------
- 문자열이 아닌 파일로 작업한다면 json.dump() 와 json.load() 를 사용해서 JSON 데이터 인코딩/디코딩
--------------------------------------------------------------------------------------
'''

import json

# JSON 데이터 쓰기
with open('d:/data/data.json', 'w') as f:
    json.dump(data, f)

# 데이터 다시 읽기
with open('d:/data/data.json', 'r') as f:
    data = json.load(f)

'''
--------------------------------------------------------------------------------------
- JSON 인코딩은 None, bool, int, float, str 과 같은 기본 타입과 함께 리스트, 튜플, 딕셔너리와 같은
  컨테이너 타입 지원 (딕셔너리의 경우 키는 문자열로 가정)
  
- JSON 스펙을 따르기 위해서 파이썬 리스트와 딕셔너리만 인코딩해야 한다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- True 는 true, False 는 false 로 None 은 null 로 매핑 되는 코드
--------------------------------------------------------------------------------------
'''

import json

print(json.dumps(False))

d = {'a' : True, 'b' : 'Hello', 'c' : None}

print(json.dumps(d))

'''
--------------------------------------------------------------------------------------
- 데이터에 중첩이 심하게 된 구조체가 포함되어 있거나 필드가 많다면 더 어렵다
  이 경우 pprint 모듈의 pprint() 함수 사용
  
- 이 함수는 키를 알파벳 순으로 나열하고 딕셔너리를 좀 더 보기 좋게 출력

- 트위터의 검색 결과를 더 예쁘게 출력하는 코드
--------------------------------------------------------------------------------------
'''

from urllib.request import urlopen
import json
from pprint import pprint

u = urlopen('https://twitter.com/search.json?q=python&rpp=5')
resp = json.loads(u.read().decode('utf-8'))

pprint(resp)

'''
--------------------------------------------------------------------------------------
- 일반적으로 JSON 디코딩은 제공 받은 데이터로부터 딕셔너리나 리스트 생성

- 다른 종류의 객체를 만들고 싶다면 json.loads() 에 object_pairs_hook 나 object_hook 를 넣는다

- OrdereDict의 순서를 지키면서 JSON 데이터를 디코딩하는 코드
--------------------------------------------------------------------------------------
'''

from collections import OrderedDict

s = '{"name": "ACME", "shares": 50, "price": 490.1}'
data = json.loads(s, object_pairs_hook=OrderedDict)

print(data)

'''
--------------------------------------------------------------------------------------
- JSON 딕셔너리를 파이썬 객체로 바꾸기
--------------------------------------------------------------------------------------
'''

import json

class JSONObject:
    def __init__(self, d):
        self.__dict__ = d

data = json.loads(s, object_hook=JSONObject)

print(data.name)
print(data.shares)
print(data.price)

'''
--------------------------------------------------------------------------------------
- JSON 데이터를 디코딩하여 생성한 딕셔너리를 __init__()에 인자로 전달

- 출력을 더 보기 좋게 하려면 json.dumps() 에 ident 인자 사용
--------------------------------------------------------------------------------------
'''

import json

class JSONObject:
    def __init__(self, d):
        self.__dict__ = d

data = json.loads(s, object_hook=JSONObject)

print(json.dumps(data))
print(json.dumps(data, indent=4))

# 출력에서 키 정렬방법
print(json.dumps(data, sort_keys=True))

'''
--------------------------------------------------------------------------------------
- 인스턴스는 일반적으로 JSON으로 직렬화하지 않는다

- 인스턴스를 직렬화하고 싶다면 인스턴스를 입력으로 받아 직렬화 가능한 딕셔너리를 반환하는 함수 제공
--------------------------------------------------------------------------------------
'''

def serialize_instance(obj):
    d = {'__classname__' : type(obj).__name__}
    d.update(vars(obj))
    return d

'''
--------------------------------------------------------------------------------------
- 인스턴스를 돌려받는 코드
--------------------------------------------------------------------------------------
'''

# 알려지지 않은 클래스에 이름을 매핑하는 딕셔너리
classes = {'Point': 'Point'}

def unserialize_object(d):
    clsname = d.pop('__classname__', None)
    if clsname:
        cls = classes[clsname]

        # __init__ 을 호출하지 않고 인스턴스 만들기
        obj = cls.__new__(cls)
        for key, value in d.items():
            setattr(obj, key, value)
            return obj

    else:
        return d






'''
--------------------------------------------------------------------------------------
6.3 단순한 XML 데이터 파싱

문제 : 단순한 XML 문서에서 데이터를 얻기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 단순한 XML 문서에서 데이터를 얻기 위해 xml.etree.ElementTree 모듈 사용

- Planet Python 에서 RSS 피드를 받아 파싱을 해야한다고 가정
--------------------------------------------------------------------------------------
'''

from urllib.request import urlopen
from xml.etree.ElementTree import parse

# RSS 피드를 다운로드하고 파싱
u = urlopen('http://planet.python.org/rss20.xml')
doc = parse(u)

# 관심 있는 태그를 뽑아서 출력
for item in doc.iterfind('channel/item'):
    title = item.findtext('title')
    date = item.findtext('pubDate')
    link = item.findtext('link')

    print(title)
    print(date)
    print(link)
    print()

'''
--------------------------------------------------------------------------------------
- xml.etree.ElementTree.parse() 함수가 XML 문서를 파싱하고 문서 객체로 만든다

- 특정 XML 요소를 찾기 위해 find(), iterfind(), findtext() 함수 사용

- 함수에 사용하는 인자는 channel/item, title 과 같이 특정 태그의 이름 사용
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- ElementTree 모듈이 나타내는 모든 요소는 파싱에 유용한 요소와 메소드를 약간 가지고 있다

- tag 요소에는 태그의 이름, text 요소에는 담겨있는 텍스트가 포함되어 있고, 필요한 경우 get() 메소드로 요소를 얻을 수 있다
--------------------------------------------------------------------------------------
'''

from urllib.request import urlopen
from xml.etree.ElementTree import parse

# RSS 피드를 다운로드하고 파싱
u = urlopen('http://planet.python.org/rss20.xml')
doc = parse(u)
e = doc.find('channel/title')

print(doc)
print(e)
print(e.tag)
print(e.text)
print(e.get('some_attribute'))





'''
--------------------------------------------------------------------------------------
6.4 매우 큰 XML 파일 증분 파싱하기

문제 : 매우 큰 XML 파일에서 최소의 메모리만 사용하여 데이터를 추출하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 증분 데이터 처리에 직면할 때면 언제나 이터레이터와 제너레이터를 떠올려야 한다

- 아주 큰 XML 파일을 증분적으로 처리하며 메모리 사용은 최소로 하는 함수 코드
--------------------------------------------------------------------------------------
'''

from xml.etree.ElementTree import iterparse

def parse_and_remove(filname, path):
    path_parts = path.split('/')
    doc = iterparse(filname, ('start', 'end'))

    # 뿌리 요소 건너뛰기
    next(doc)

    tag_stack = []
    elem_stack = []
    for event, elem in doc:
        if event == 'start':
            tag_stack.append(elem.tag)
            elem_stack.append(elem)
        elif event == 'end':
            if tag_stack == path_parts:
                yield elem
                elem_stack[-2].remove(elem)
            try:
                tag_stack.pop()
                elem_stack.pop()
            except IndexError:
                pass

'''
--------------------------------------------------------------------------------------
- ZIP 코드별로 순위를 매기는 스크립트 작성 코드
--------------------------------------------------------------------------------------
'''

from xml.etree.ElementTree import parse
from collections import Counter

potholes_by_zip = Counter()
doc = parse('potholes.xml')

for pothole in doc.iterfind('row/row'):
    potholes_by_zip[pothole.findtext('zip')] += 1

for zipcode, num in potholes_by_zip.most_common():
    print(zipcode, num)

'''
=> 위 스크립트는 XML 파일 전체를 읽어 메모리에 넣는다는 문제점 
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 위의 코드 수정
--------------------------------------------------------------------------------------
'''

from collections import Counter
from xml.etree.ElementTree import iterparse

def parse_and_remove(filname, path):
    path_parts = path.split('/')
    doc = iterparse(filname, ('start', 'end'))

    # 뿌리 요소 건너뛰기
    next(doc)

    tag_stack = []
    elem_stack = []
    for event, elem in doc:
        if event == 'start':
            tag_stack.append(elem.tag)
            elem_stack.append(elem)
        elif event == 'end':
            if tag_stack == path_parts:
                yield elem
                elem_stack[-2].remove(elem)
            try:
                tag_stack.pop()
                elem_stack.pop()
            except IndexError:
                pass

potholes_by_zip = Counter()
data = parse_and_remove('potholes.xml', 'row/row')

for pothole in data:
    potholes_by_zip[pothole.findtext('zip')] += 1

for zipcode, num in potholes_by_zip.most_common():
    print(zipcode, num)

'''
--------------------------------------------------------------------------------------
- ElementTree 모듈의 두 가지 필수 기능에 의존
  첫번째는 iterparse() 메소드로 XML 문서를 증분 파싱할 수 있게 된다
  이 메소드를 사용하기 위해서는 파일이름과 start, end, start-ns, end-ne 중 하나 이상을 포함한 이벤트 리스트를 넘겨주어야 한다
  
- iterparse() 가 생성한 이터레이터는 (event, elem)으로 구성된 튜플을 만드는데 event 는 리스팅된
  이벤트 중 하나이고, elem은 결과로 나온 XML 요소
  
- start 이벤트는 요소가 처음 생성되었지만 다른 데이터를 만들지 않았을때 생성된다

- end 이벤트는 요소를 마쳤을 때 생성된다

- start-ns 와 end-ns 이벤트는 XML 네임스페이스 선언을 처리하기 위해 사용된다
--------------------------------------------------------------------------------------
'''

