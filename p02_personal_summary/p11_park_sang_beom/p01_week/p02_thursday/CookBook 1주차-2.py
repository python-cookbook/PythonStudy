'''
--------------------------------------------------------------------------------------
1.18 시퀀스 요소에 이름 매핑

문제 : 리스트나 튜플의 위치로 요소에 접근하는 코드는 가독성이 떨어지고 위치에 의존하는 코드의 구조도
      이름으로 접근 가능하도록 수정
--------------------------------------------------------------------------------------
'''


'''
--------------------------------------------------------------------------------------
- collections.namedtuple() 함수는 크지 않은 오버헤드로 이 기능 구현하고 tuple 타입의 서브클래스를 
  반환하는 팩토리 메소드 (타입이름과 
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
sub = Subscriber('jonesy@example.com', '2012-10-19')

print(sub)
print(sub.addr)
print(sub.joined)

'''
--------------------------------------------------------------------------------------
- namedtuple 의 인스턴스는 일반적으로 클래스 인스턴스와 비슷해 보이지만 튜플
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
sub = Subscriber('jonesy@example.com', '2012-10-19')

addr, joined = sub

print(len(sub))
print(addr)
print(joined)

'''
--------------------------------------------------------------------------------------
- named tuple 은 주로 요소의 위치를 기반으로 구현 따라서 데이터베이스로부터 거대한 
  튜플 리스트를 받고 요소의 위치로 접근
--------------------------------------------------------------------------------------
'''

def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] * rec[2]
    return total

'''
--------------------------------------------------------------------------------------
- namedtuple 사용한 코드
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])

def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total

'''
=> records 시퀀스에 이미 인스턴스가 포함되어 있기 때문에 Stock 네임드 튜플로 명시적 형변환 X
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- namedtuple 은 저장 공간을 더 필요로 하는 딕셔너리 대신 사용할 수 있다
  딕셔너리를 포함한 방대한 자료 구조를 구상하고 있다면 namedtuple을 사용하는 것이 더 효율적
  (딕셔너리와는 다르게 네임드 튜플은 수정할 수 없다)
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])

s = Stock('ACME', 100, 123.45)

print(s)

s.shares = 75

'''
=> Stock(name='ACME', shares=100, price=123.45)

=> Traceback (most recent call last):
   File "D:/python/Source/CookBook/CookBook 1주차-2.py", line 616, in <module>
   s.shares = 75
   AttributeError: can't set attribute
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 속성을 수정해야 한다면 namedtuple 인스턴스의  _replace() 메소드 사용
  (지정한 값을 치환하여 완전히 새로운 네임드 튜플을 만든다)
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])

s = Stock('ACME', 100, 123.45)
s = s._replace(shares=75)

print(s)

'''
--------------------------------------------------------------------------------------
- _repalce() 메소드를 사용하면 옵션이나 빈 필드롤 가진 네임드 튜플을 간단히 만들 수 있다
   일단 기본 값을 가진 프로토타입 튜플을 만들고, _replace()로 치환된 값을 가진 새로운 인스턴스를 만든다
--------------------------------------------------------------------------------------
'''

from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
stock_prototype = Stock('', 0, 0.0, None, None)

def dict_to_stock(s):
    return stock_prototype._replace(**s)

a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}

print(dict_to_stock(a))
print(dict_to_stock(b))

'''
=> 여러 인스턴스 요소를 빈번히 수정해야 하는
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
1.19 데이터를 변환하면서 줄이기

문제 : 감소 함수(sum(), min(), max())를 실행해야 하는데 먼저 데이터를 변환하는 필터링 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 데이터를 줄이면서 변형하는 가장 우아한 방식은 생성자 표현식 사용 (정사각형 넓이의 합 계산)
--------------------------------------------------------------------------------------
'''

nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)

print(s)





'''
--------------------------------------------------------------------------------------
1.20 여러 매핑을 단일 매핑으로 합치기

문제 : 딕셔너리나 매핑일 여러 개 있고, 자료 검색이나 데이터 확인을 위해서 하나의 매핑으로 합치기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 두 딕셔너리에 모두 검색을 해야 할 상황이라고 가정
  (우선 a에서 데이터를 검색하고 그 후 b에 그 데이터가 있는지 검색)
--------------------------------------------------------------------------------------
'''

from collections import ChainMap

a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
c = ChainMap(a,b)

print(c['x'])
print(c['y'])
print(c['z'])

'''
--------------------------------------------------------------------------------------
- ChainMap은 매핑을 여러 개 받아서 하나처럼 보이게 한다. 하지만 그렇게 보이는 것 뿐 하나로 
  합치는 것은 아니다. 단지 매핑에 대한 리스트를 유지하면서 리스트를 스캔하도록 
  일반적인 딕셔너리 동작 재정의
--------------------------------------------------------------------------------------
'''

from collections import ChainMap

a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
c = ChainMap(a,b)

print(len(c))
print(list(c.keys()))
print(list(c.values()))

'''
=> 중복 키가 있으면 첫 번째 매핑의 값을 사용
   언제나 a의 값을 참조하며 b의 값은 참조하지 않는다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 매핑의 값을 변경하는 동작은 언제나 리스트의 첫 번째 매핑에 영향을 준다 
--------------------------------------------------------------------------------------
'''

from collections import ChainMap

a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
c = ChainMap(a,b)

c['z'] = 10
c['w'] = 40
del c['x']
print(a)

del c['y']

'''
=> {'z': 10, 'w': 40}

=> Traceback (most recent call last):
   File "C:\Users\park\AppData\Local\Programs\Python\Python36\lib\collections\__init__.py", line 936, in __delitem__
   del self.maps[0][key]
   KeyError: 'y'
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- ChainMap 프로그래밍 언어의 변수와 같이 범위가 있는 값(즉, 전역변수, 지역변수) 에 사용하면 유용
--------------------------------------------------------------------------------------
'''

from collections import ChainMap

a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
c = ChainMap(a,b)

values = ChainMap()
values['x'] = 1
values = values.new_child()
values = values.new_child()
values['x'] = 3

print(values)
print(values['x'])

values = values.parents

print(values['x'])

values = values.parents

print(values['x'])
print(values)

'''
--------------------------------------------------------------------------------------
- ChainMap의 대안으로 update()를 사용해 딕셔너리를 하나로 합칠 수도 있다
--------------------------------------------------------------------------------------
'''

a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }

merged = dict(b)
merged.update(a)

print(merged['x'])
print(merged['y'])
print(merged['z'])

a['x'] = 13
print(merged['x'])

'''
=> 완전히 별개의 딕셔너리 객체를 새로 만들어야 한다(혹은 기존 딕셔너리의 내용을 변경)
   또한 원본 딕셔너리의 내용이 변경된다 해도 합쳐놓은 딕셔너리에 반영되지 않는다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- ChainMap 은 원본 딕셔너리를 참조하기 때문에 이와 같은 문제가 발생하지 않는다
--------------------------------------------------------------------------------------
'''

from collections import ChainMap

a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
merged = ChainMap(a, b)

print(merged['x'])

a['x'] = 42

print(merged['x'])





'''
--------------------------------------------------------------------------------------
Chapter 2 문자열과 텍스트
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
2.1 여러 구분자로 문자열 나누기

문제 : 문자열을 필드로 나누고 싶지만 구분자가 문자열에 일관적이지 않다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 문자열 객체의 split() 메소드는 여러 개의 구분자나 구분자 주변의 공백까지는 고려하지는 않는다
  좀 더 유연해져야 할 필요가 있다면 re.split() 메소드 사용
--------------------------------------------------------------------------------------
'''

import re

line = 'asdf fjdk; afed,fjek,asdf,        foo'

print(re.split(r'[;,\s]\s*',line))

'''
--------------------------------------------------------------------------------------
- re.split() 함수는 분리 구문마다 여러 패턴을 명시할 수 있다는 점에 유리
  re.split() 을 사용할 때는 괄호 안에 묶인 정규 표현식 패턴이 캡쳐 그룹이 된다
  캡쳐 그룹을 사용하면 매칭된 텍스트에도 결과 포함  
  (쉼표, 세미콜론, 공백문자와 뒤이어 나오는 하나 이사의 공백문자 모두를 분리 구문으로 사용)
--------------------------------------------------------------------------------------
'''

import re

line = 'asdf fjdk; afed,fjek,asdf,        foo'
fields = re.split(r'(;|,|\s)\s*',line)

print(fields)

'''
--------------------------------------------------------------------------------------
- 구문 문자만 추출할 경우
--------------------------------------------------------------------------------------
'''

import re

line = 'asdf fjdk; afed,fjek,asdf,        foo'
fields = re.split(r'(;|,|\s)\s*',line)
values = fields[::2]
delimiters = fields[1::2] + ['']

print(values)
print(delimiters)
print(''.join(v+d for v,d in zip(values,delimiters)))

'''
--------------------------------------------------------------------------------------
- 분리 구문을 결과에 포함시키고 싶지 않으면 정규 표현식에 괄호를 사용한다면 논캡쳐 그룹 사용
--------------------------------------------------------------------------------------
'''

import re

line = 'asdf fjdk; afed,fjek,asdf,        foo'
print(re.split(r'(?:,|;|\s)\s*', line))





'''
--------------------------------------------------------------------------------------
2.2 문자열 처음이나 마지막에 텍스트 매칭

문제 : 문자열 처음이나 마지막에 파일 확장자, URL 스킴 등 특정 텍스트 패턴이 포함되었는지 검사하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 문자열 처음이나 마지막에 패턴이 포함되었는지 확인하는 간단한 방법으로는 
  str.start, switch(), str.endswitch() 
--------------------------------------------------------------------------------------
'''

filename = 'spam.txt'
url = 'http://www.python.org'

print(filename.endswith('.txt'))
print(filename.startswith('file:'))
print(url.startswith('http:'))

'''
--------------------------------------------------------------------------------------
- 여러 개의 선택지를 검사해야 한다면 검사하고 싶은 값을 튜플에 담아 
  startswitch(), endswitch() 에 전달
--------------------------------------------------------------------------------------
'''

import os

filename = os.listdir('.')

print(filename)
print([name for name in filename if name.endswith('.py')])
print(any(name.endswith('.py') for name in filename))

'''
--------------------------------------------------------------------------------------
- 입력 값을 리스트나 세트로 가지고 있다면 tuple()을 사용해서 먼저 변환해 주어야 한다
--------------------------------------------------------------------------------------
'''

choices = ['http:', 'ftp:']
url = 'http://www.python.org'

print(url.startswith(tuple(choices)))

'''
--------------------------------------------------------------------------------------
- startswitch() 와 endswitch() 메소드는 접두어와 접미어를 검사할 때 매우 편리
  (슬라이스를 사용하면 비슷한 동작을 할 수 있지만 코드의 가독성이 많이 떨어진다)
--------------------------------------------------------------------------------------
'''

filename = 'spam.txt'
url = 'http://www.python.org'

print(filename[-4:] == '.txt')
print(url[:5] == 'http:' or url[:6] == 'http:' or url[:4] == 'org')

'''
--------------------------------------------------------------------------------------
- 정규식 표현 가능
--------------------------------------------------------------------------------------
'''

import re

url = 'http://www.python.org'

print(re.match('http:|https:|ftp:', url))





'''
--------------------------------------------------------------------------------------
2.3 쉘 와일드카드 패턴으로 문자열 매칭

문제 : Unix 셸에 사용하는 것과 동일한 와일드카드 패턴을 텍스트 매칭에 사용하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- fnmatch 모듈의 두함수 fnmatch() 와 fnmatchcase()
--------------------------------------------------------------------------------------
'''

from fnmatch import fnmatch, fnmatchcase

print(fnmatch('foo.txt', '*.txt'))
print(fnmatch('foo.txt', '?oo.txt'))

'''
--------------------------------------------------------------------------------------
'''

from fnmatch import fnmatch, fnmatchcase

names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']

print(fnmatch('Dat45.csv', 'Dat[0-9]*'))
print([name for name in names if fnmatch(name, 'Dat*.csv')])

'''
--------------------------------------------------------------------------------------
- fnmatchcase() 메소드는 지정한 소문자 혹은 대문자에 정확히 일치하는 것만 찾아낸다
--------------------------------------------------------------------------------------
'''

from fnmatch import fnmatch, fnmatchcase

print(fnmatchcase('foo.txt', '*.TXT'))

'''
--------------------------------------------------------------------------------------
- 데이터 프로세싱에도 사용 가능
--------------------------------------------------------------------------------------
'''

from fnmatch import fnmatchcase

addresses = ['5412 N CLARK ST','1060 W ADDISON ST','1039 W GRANVILLE AVE',
             '2122 N CLARK ST','4802 N BROADWAY']

print([addr for addr in addresses if fnmatchcase(addr,'* ST')])
print([addr for addr in addresses if fnmatchcase(addr,'54[0-9][0-9] *CLARK*')])





'''
--------------------------------------------------------------------------------------
2.4 텍스트 패턴 매칭과 검색

문제 : 특정 패턴에 대한 텍스트 매칭이나 검색 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 매칭하려는 텍스트가 간단하다면 str.find(), str.endswitch(), str.startswitch() 사용
--------------------------------------------------------------------------------------
'''

text = 'yeah, but no, but yeah, but no, but yeah'

print(text == 'yeah')
print(text.startswith('yeah'))
print(text.endswith('no'))
print(text.find('no'))

'''
--------------------------------------------------------------------------------------
- 정규식 표현 사용
--------------------------------------------------------------------------------------
'''

import re

text1 = '1/27/2012'
text2 = 'Nov 27,2012'

if re.match(r'\d+/\d+/\d+', text1):
    print('yes')
else:
    print('no')

'''
--------------------------------------------------------------------------------------
'''

import re

text1 = '1/27/2012'
text2 = 'Nov 27,2012'

if re.match(r'\d+/\d+/\d+',text2):
    print('yes')
else:
    print('no')

'''
--------------------------------------------------------------------------------------
- 동일한 패턴으로 매칭을 많이 수행할 예정이라면 정규 표현식을 미리 컴파일 해서 패턴 객체로 생성
--------------------------------------------------------------------------------------
'''

import re

text1 = '1/27/2012'
text2 = 'Nov 27,2012'

datepat = re.compile(r'\d+/\d+/\d+')
if datepat.match(text1):
    print('yes')
else:
    print('no')

'''
--------------------------------------------------------------------------------------
'''

import re

text1 = '1/27/2012'
text2 = 'Nov 27,2012'

datepat = re.compile(r'\d+/\d+/\d+')
if datepat.match(text2):
    print('yes')
else:
    print('no')

'''
--------------------------------------------------------------------------------------
- match()는 항상 문자열 처음에서 찾기를 시도, 텍스트 전체에 걸쳐 패턴을 찾으려면 findall() 메소드 사용
--------------------------------------------------------------------------------------
'''

import re

text1 = '1/27/2012'
text2 = 'Nov 27,2012'
datepat = re.compile(r'\d+/\d+/\d+')
text = 'Today is 11/27/2012. Pycon starts 3/13/2013.'

print(datepat.findall(text))

'''
--------------------------------------------------------------------------------------
- 캡쳐 그룹을 사용하면 매칭된 텍스트에 작업할 때 각 그룹을 개별적으로 추출 가능
--------------------------------------------------------------------------------------
'''

import re

datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('11/27/2012')

print(m)
print(m.group(0))
print(m.group(1))
print(m.group(2))
print(m.group(3))
print(m.groups())

'''
--------------------------------------------------------------------------------------
'''

import re

datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('11/27/2012')
month, day, year = m.groups()
text = ('Today is 11/27/2012. Python starts 3/13/2013.')

print(text)
print(datepat.findall(text))

for month, day, year in datepat.findall(text):
    print('{}-{}-{}'.format(year, month, day))

'''
--------------------------------------------------------------------------------------
- findall() 메소드는 텍스트를 검색하고 모든 매칭을 찾아 리스트로 반환
  Findlter() 메소드는 한 번에 결과를 얻지 않고 텍스트를 순환하며 찾는다
--------------------------------------------------------------------------------------
'''

import re

datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('11/27/2012')
month, day, year = m.groups()
text = ('Today is 11/27/2012. Python starts 3/13/2013.')

for m in datepat.finditer(text):
    print(m.groups())

'''
--------------------------------------------------------------------------------------
- match() 메소드는 문자열의 처음만 확인한다. 예상치 못한 것에 매칭할 확률도 있다
--------------------------------------------------------------------------------------
'''

import re

datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
m = datepat.match('11/27/2012abcdef')

print(m)
print(m.group())

'''
--------------------------------------------------------------------------------------
- 정확한 매칭을 위해서 패턴에 문자열 마지막을 나타내는 $ 부호 사용
--------------------------------------------------------------------------------------
'''

import re

datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
datepat.match('11/27/2012abcdef')
datepat.match('11/27/2012')

print(datepat.match('11/27/2012'))

'''
--------------------------------------------------------------------------------------
- re 모듈의 모듈 레벨 함수를 바로 사용 가능
--------------------------------------------------------------------------------------
'''

import re

text = ('Today is 11/27/2012. Python starts 3/13/2013.')

print(re.findall(r'(\d+)/(\d+)/(\d+)', text))





'''
--------------------------------------------------------------------------------------
2.5 텍스트 검색과 치환

문제 : 문자열에서 텍스트 패턴을 검색하고 치환하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 간단한 패턴이라면 str.replace() 메소드 사용
--------------------------------------------------------------------------------------
'''

text = 'yeah, but no, but yeah, but no, but yeah'

print(text.replace('yeah','yep'))

'''
--------------------------------------------------------------------------------------
- 조금 더 복잡한 패턴이라면 re 모듈의 sub() 함수/메소드 사용
--------------------------------------------------------------------------------------
'''

import re

text = 'Today is 11/27/2012. Pycon starts 3/13/2013.'

print(re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2',text))

'''
=> sub() 의 첫번째 인자는 매칭을 위한 패턴이고 두번째 인자는 치환을 위한 패턴
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 동일한 패턴을 사용한 치환을 계속해야 한다면 성능 향상을 위해 컴파일링 고려
--------------------------------------------------------------------------------------
'''

import re

text = 'Today is 11/27/2012. Pycon starts 3/13/2013.'
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')

print(datepat.sub(r'\3-\1-\2',text))

'''
--------------------------------------------------------------------------------------
- 더 복잡한 치환을 위해서 콜백 함수 명시 가능
--------------------------------------------------------------------------------------
'''

from calendar import month_abbr
import re

def change_date(m):
    mon_name = month_abbr[int(m.group(1))]
    return '{}{}{}'.format(m.group(2), mon_name, m.group(3))

text = 'Today is 11/27/2012. Pycon starts 3/13/2013.'
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')

print(datepat.sub(change_date, text))

'''
--------------------------------------------------------------------------------------
- 인자가 되는 치환 콜백은 match() 나 find() 에서 반환한 매치 객체 사용
  매치에서 특정 부분을 추출하려면 group() 메소드 사용, 치환된 텍스트 반환
  만약 치환된 텍스트를 받기 전에 치환이 몇 번 발생했는지 알고 싶다면 re.sub() 사용
--------------------------------------------------------------------------------------
'''

import re

text = 'Today is 11/27/2012. Pycon starts 3/13/2013.'
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
newtext, n = datepat.subn(r'\3-\1-\2', text)

print(newtext)
print(n)





'''
--------------------------------------------------------------------------------------
2.6 대소문자를 구별하지 않는 검색과 치환

문제 : 텍스트를 검색하고 치환할 때 대소문자를 구별하지 않기
--------------------------------------------------------------------------------------
'''

import re

text = 'UPPER PYTHON, lower python, Mixed Python'

print(re.findall('python',text,flags=re.IGNORECASE))
print(re.sub('python','snake',text,flags = re.IGNORECASE))

'''
--------------------------------------------------------------------------------------
- 치환된 텍스트의 대소문자가 원본의 대소문자와 일치하지 않아서 다음과 같이 함수를 만들어 수정
--------------------------------------------------------------------------------------
'''

import re

text = 'UPPER PYTHON, lower python, Mixed Python'

def matchcase(word):
    def replace(m):
        text = m.group()
        if text.isupper():
            return word.upper()
        elif text.islower():
            return word.lower()
        elif text[0].isupper():
            return word.capitalize()
        else:
            return word
    return replace

print(re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE))

'''
=> re.IGNORECASE는 유니코드가 포함된 작업을 하기에는 부족할 수 있다 
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
2.7 가장 짧은 매칭을 위한 정규 표현식

문제 : 정규 표현식을 사용한 텍스트 매칭을 하고 싶지만 텍스트에서 가장 긴 부분을 찾아낸다
      가장 짧은 부분을 찾아내고 싶다면 어떻게 해야 하나
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 문장 구분자에 둘러싸여 있는 텍스트를 찾을 때 종종 문제 발생
  (r’\”(.*)\”’ 패턴은 따옴표에 둘러싸인 텍스트를 찾도록 의도, * 문자는 정규 표현식에서 기본적으로
  탐욕스럽게 소비되므로 가장 긴 텍스트를 찾게되면 text2에서 원치않게 인용문 두 개에 동시에 매칭된다)

- 이 문제를 해결하려면 * 앞에 ?를 붙인다!
--------------------------------------------------------------------------------------
'''

import re

text1 = 'Computer says "no."'
text2 = 'Computer says "no." Phone says "yes."'
str_pat = re.compile(r'\"(.*?)\"')

print(str_pat.findall(text1))
print(str_pat.findall(text2))





'''
--------------------------------------------------------------------------------------
2.8 여러 줄에 걸친 정규 표현식 사용

문제 : 여러 줄에 걸친 정규 표현식 매칭 사용하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 점(.)을 사용한 텍스트 매칭을 할 때 이 문자가 개행문에 매칭하지 않는다는 사실을 잊었을 때 발생

-  이 문제를 해결하려면 개행문에 패턴 추가!
--------------------------------------------------------------------------------------
'''

import re

comment = re.compile(r'/\*((?:.|\n)*?)\*/') # 패턴 추가 후
text1 = '/* this is a comment*/'
text2 = '''/* this is a
              multiline comment */
'''
print(comment.findall(text1))
print(comment.findall(text2))

'''
=> (?:.|\n) 은 논캡쳐 그룹 명시!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- re.compile() 함수에 re.DOTALL 이라는 유용한 플래그 사용하면 정규 표현식의 점(.)이 
  개행문을 포함한 모든 문자에 매칭
--------------------------------------------------------------------------------------
'''

import re

comment = re.compile(r'/\*(.*?)\*/', re.DOTALL)

text1 = '/* this is a comment*/'
text2 = '''/* this is a
              multiline comment */
'''

print(comment.findall(text2))

'''
=> 아주 복잡한 패턴을 사용하거나 여러 정규 표현식을 합쳐 토큰화를 한다거나 할 때 문제가 발생할 수 있다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
2.9 유니코드 텍스트 노멀화

문제 : 유니코드 문자열 작업을 할 때 모든 문자열에 동일한 표현식을 갖도록 보장하기
--------------------------------------------------------------------------------------
'''

s1 = 'Spicy Jalape\u00f1o'
s2 = 'Spicy Jalapen\u0303o'

print(s1)
print(s2)
print(s1 == s2)
print(len(s1))
print(len(s2))

'''
--------------------------------------------------------------------------------------
- 여러 표현식을 갖는다는 것은 문자열을 비교하는 프로그램의 측면에서 문제가 되기 때문에 
  이를 해결 방안 Unicodedata 모듈로 텍스트를 노멀화 해서 표준 표현식으로 바꾼다
--------------------------------------------------------------------------------------
'''

import unicodedata

s1 = 'Spicy Jalape\u00f1o'
s2 = 'Spicy Jalapen\u0303o'
t1 = unicodedata.normalize('NFC', s1)
t2 = unicodedata.normalize('NFC', s2)
t3 = unicodedata.normalize('NFD', s1)
t4 = unicodedata.normalize('NFD', s2)

print(t1 == t2)
print(ascii(t1))
print(t3 == t4)
print(ascii(t3))

'''
=> normalize() 의 첫번째 인자는 문자열을 어떻게 노멀화할 것인지 지정
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- NFKC 와 NFKD 노멀화 지원
--------------------------------------------------------------------------------------
'''

import unicodedata

s = '\ufb01'

print(s)
print(unicodedata.normalize('NFD', s))
print(unicodedata.normalize('NFKD', s))
print(unicodedata.normalize('NFKC', s))

'''
--------------------------------------------------------------------------------------
- 발음 구별 부호를 모두 제거 하기
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
2.10 정규 표현식에 유니코드 사용

문제 : 텍스트 프로세싱에 정규 표현식을 사용할 때 유니코드 문자 처리 걱정
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 유니코드 처리는 re 모듈 제공
--------------------------------------------------------------------------------------
'''

import re
num = re.compile('\d+')

print(num.match('123'))
print(num.match('\u0661\u0662\u0663'))





'''
--------------------------------------------------------------------------------------
2.11 문자열에서 문자 잘라내기

문제 : 텍스트의 처음, 끝, 중간에서 원하지 않는 공백문 등을 잘라내기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- strip() 메소드를 사용하면 문자열의 처음과 끝에서 문자를 잘라낼 수 있다

- lstrip() 과 rstrip() 은 문자열의 왼쪽과 오른쪽의 문자를 잘라내고 공백문을 잘라내지만 
  원하는 문자 지정 가능
--------------------------------------------------------------------------------------
'''

s = '     hello world \n'
t = '-------hello======'

print(s.strip())
print(s.lstrip())
print(s.rstrip())
print(t.lstrip('-'))
print(t.strip('-='))

'''
--------------------------------------------------------------------------------------
- 문자열 중간의 공백문을 없애려면 replace() 메소드나 정규 표현식의 치환과 같은 다른 기술 사용
--------------------------------------------------------------------------------------
'''

import re

s = ' hello            world       \n'

print(s.replace(' ', ''))
print(re.sub('\s+',' ',s))





'''
--------------------------------------------------------------------------------------
2.12 텍스트 정리

문제 : 당신의 웹페이지에 python(이상한 문자) 라는 텍스트 입력을 했을 때 이를 정리 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 문자열 함수(str.upper(), str.lower()) 를 사용해서 텍스트를 표준 케이스로 변환
  str.replace() 나 re.sub() 을 사용한 치환은 특정 문자 시퀀스를 아예 없애거나 바꾸는데 집중


- 특정 범위의 문자나 발음 구별 구호를 없애려고 할 때 str.translate() 메소드 사용
  문자열 공백문을 잘라내기 위해서는 작은 변환 테이블을 만들어 놓고 translate() 사용
  
- \t와 \f 와 같은 공백문은 띄어쓰기 하나로 치환, 복귀코드 \r은 아예 삭제
--------------------------------------------------------------------------------------
'''

s = 'p\xfdt\fis\tawesome\r\n'
print(s)

remap = {ord('\t') : ' ', ord('\f') : ' ', ord('\r') : None}
a = s.translate(remap)

print(a)

'''
--------------------------------------------------------------------------------------
- 간단한 치환을 하려면 str.replace() 메소드를 사용하는 것이 가장 빠르다
  공백문을 없애려고 한다면 다음과 같은 코드가 translate() 나 정규 표현식을 사용하는것보다 빠르다
  (translate() 메소드는 복잡한 문자 리매핑(remapping) 이나 삭제에 아주 유용)
--------------------------------------------------------------------------------------
'''

def clean_space(s):
    s = s.replace('\r',  '')
    s = s.replace('\t',  ' ')
    s = s.replace('\f',  ' ')
    return s

'''
--------------------------------------------------------------------------------------
2.13 텍스트 정렬

문제 : 텍스트를 특정 형식에 맞춰 정렬 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 정렬 메소드로는 ljust(), rjust(), center()
  (채워 넣기 문자 사용 가능, 정렬에 format() 함수 사용 가능, 인자로 <,>,^ 사용
  공백 대신 특정 문자를 채워 넣고 싶다면 정렬 문자 앞에 그 문자를 지정
  Format() 을 사용하면 문자열뿐만 아니라 숫자 값 등 모든 값에 동작한다)
--------------------------------------------------------------------------------------
'''

text = 'Hello World'
x = 1.2345

print(text.ljust(20))
print(text.rjust(20))
print(text.center(20))
print(text.rjust(20,'='))
print(text.center(20,'*'))
print(format(text,'>20'))
print(format(text,'<20'))
print(format(text,'^20'))
print(format(text,'=^20s'))
print('{:>10s}{:>10s}'.format('Hello', 'World'))
print(format(x, '>10'))
print(format(x, '^10.2f'))





'''
--------------------------------------------------------------------------------------
2.14 문자열 합치기

문제 : 작은 문자열 여러 개를 합쳐 하나의 긴 문자열 만들기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 합치고자 하는 문자열이 시퀀스나 순환 객체 안에 있다면 join() 메소드 사용
--------------------------------------------------------------------------------------
'''

parts = ['Is','Chicago','Not','Chicago?']

print(' '.join(parts))
print(''.join(parts))

'''
--------------------------------------------------------------------------------------
- 문자열의 수가 아주 작다면 +를 사용하는 것만으로도 충분
  (+ 연산자는 조금 더 복잡한 문자열 서식 연산에 사용해도 잘 동작
   문자열을 합치려고 할 때는 단순히 옆에 붙여 놓기만 해도 된다)
--------------------------------------------------------------------------------------
'''

a = 'Is Chicago'
b = 'Not Chicago'
c = 'Hello' 'World'

print(a + ' ' + b)
print('{} {}'.format(a, b))
print(c)

'''
=> + 연산자로 많은 문자열을 합치려고 하면 메모리 복사와 가비지 컬렉션(garbage collection)으로
   인해 매우 비효율적! 
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- += 연산자는 새로운 문자열 객체를 만들어 내기 때문에 join() 메소드보다 실행속도가 약간 느리다
  (생성자 표현식으로 합치는 방식 코드)
--------------------------------------------------------------------------------------
'''

data = ['ACME', 50, 91.1]

print(','.join(str(d) for d in data))





'''
--------------------------------------------------------------------------------------
2.15 문자열에 변수 사용

문제 : 문자열에 변수를 사용하고 이 변수에 맞는 값 채우기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- format() 메소드를 이용해 변수 값을 치환하는 방법으로 비슷하게 흉내 낼 수 있다
--------------------------------------------------------------------------------------
'''

s = '{name} has {n} message'

print(s.format(name='Guido',n=37))

'''
--------------------------------------------------------------------------------------
- 치환할 값이 변수에 들어있다면 format_map() 과 vars() 를 함께 사용
  (vars() 에는 인스턴스를 사용할 수도 있다)
--------------------------------------------------------------------------------------
'''

name = 'Guido'
n = 37
s = '{name} has {n} message'

class Info:
    def __init__(self, name, n):
        self.name = name
        self.n = n

a = Info('Guido', 37)

print(s.format_map(vars()))
print(s.format_map(vars(a)))

'''
=> format() 과 format_map() 을 사용할 때 빠진 값이 있으면 제대로 동작하지 않는다는 단점!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 위의 문제 해결 코드
--------------------------------------------------------------------------------------
'''

name = 'Guido'
n = 37
s = '{name} has {n} message'

class safesub(dict):
    def __missing__(self, key):
        return '{' + key + '}'

del n

print(s.format_map(safesub(vars())))

'''
--------------------------------------------------------------------------------------
- 코드에서 변수 치환을 빈번히 사용할 것 같다면 치환하는 작업을 유틸리티 함수에 모아놓고 
  프레임 핵(frame hack) 으로 사용
--------------------------------------------------------------------------------------
'''

import sys

class safesub(dict):
    def __missing__(self, key):
        return '{' + key + '}'

def sub(text):
    return text.format_map(safesub(sys._getframe(1).f_locals))

name = 'Guido'
n = 37

print(sub('Hello {name}'))
print(sub('You have {n} message.'))
print(sub('Your favorite color is {color}'))

'''
--------------------------------------------------------------------------------------
- 문자열 서식화 혹은 템플릿 사용
--------------------------------------------------------------------------------------
'''

import string
name = 'Guido'
n = 37
s = string.Template('$name has $n message. ')

print(s.substitute(vars()))

'''
=> format() 과 format_map() 메소드를 사용하는 것이 현대적

=> format() 을 사용하면 문자열 서식화와 관련 있는 모든 기능(정렬, 공백, 숫자 서식 등) 사용
    Template 문자열 객체에서는 지원하지 않는다

=> __missing__() 메소드를 통해 없는 값을 처리할 수 있다

=> safesub 클래스에서 이 메소드를 정의하여, 없는 값을 기본으로 처리, 이렇게 하면 KeyError 예외가
   발생하지 않고 값이 없음을 알리는 문자열 반환

=> sub() 함수는 sys._getframe(1) 로 호출자의 스택 프레임 반환
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
2.16 텍스트 열의 개수 고정

문제 : 긴 문자열의 서식을 바꿔 열의 개수 조절 
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- textwrap 모듈을 사용해서 텍스트를 재서식화(reformat) 하기
--------------------------------------------------------------------------------------
'''

import textwrap

s = "Look into my eyes, look into my eyes, the eyes, the eyes, \
    the eyes, not around the eyes, don't look around the eyes, \
    look into my eyes, you're under."

print(textwrap.fill(s, 70))
print(textwrap.fill(s, 40))
print(textwrap.fill(s, 40, initial_indent='    '))
print(textwrap.fill(s, 40, subsequent_indent='    '))

'''
=> 텍스트를 출력하기 전에 textwrap 모듈을 사용하면 깔끔하게 서식을 맞출 수 있다. 특히 터미널에 사용할 때
   텍스트에 적합. 터미널의 크기를 얻으려면 os.get_terminal_size() 사용
--------------------------------------------------------------------------------------
'''