'''
--------------------------------------------------------------------------------------
Chapter 1 자료 구조와 알고리즘
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
1.1	시퀀스를 개별 변수로 나누기

문제 : N개의 요소를 가진 튜플이나 시퀀스가 있는데 이를 변수 N개로 나누기
--------------------------------------------------------------------------------------
'''


'''
- 모든 시퀀스(혹은 이터레이팅 가능한 것)는 간단한 할당문을 사용해서 개별 변수로 나눌 수 있다
'''

p = (4, 5)
x, y = p

print(x)
print(y)

'''
--------------------------------------------------------------------------------------
'''

data = ['ACME', 50, 91.1, (2012, 12, 21)]
name, share, price, data = data

print(name)
print(data)

'''
--------------------------------------------------------------------------------------
'''

data = ['ACME', 50, 91.1, (2012, 12, 21)]
name, share, price, (year, mon, day) = data

print(name)
print(year)
print(mon)
print(day)

'''
=> 모든 시퀀스는 할당문을 사용해서 개별 변수로 나눌 수 있다
   단 한 가지 주의해야 할 점은 변수의 개수가 시퀀스에 일치해야 한다!!!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 언패킹
    튜플이나 리스트뿐만 아니라 순환 가능한 모든 객체에 적용
    문자열, 파일, 이터레이터(iterator), 제너레이터(generator)
--------------------------------------------------------------------------------------
'''

s = 'Hello'
a, b, c, d, e = s

print(a)
print(b)
print(e)

'''
--------------------------------------------------------------------------------------
- 언패킹(특정 값을 무시하는 방법)
--------------------------------------------------------------------------------------
'''

data = ['ACME', 50, 90.1, (2012, 12, 21)]
_, shares, price, _ = data

print(shares)
print(price)





'''
--------------------------------------------------------------------------------------
1.2	임의 순환체의 요소 나누기

문제 : 순환체를 언패킹하려는데 요소가 N개 이상 포함되어 값이 너무 많습니다 라는 예외 발생
--------------------------------------------------------------------------------------
'''

record = ('Dave', 'dave@example.com', '777-555-1212', '847-555-1212')
name, email, *phone_numbers = record

print(name)
print(email)
print(phone_numbers)

'''
=> phone_numbers 의 값이 하나 이상이든 리스트에서 빠져 있거나 타입검사하는 등의 작업 필요X
--------------------------------------------------------------------------------------
'''

*trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]

print(trailing)
print(current)

'''
--------------------------------------------------------------------------------------
- 별표구문(*)

    길이가 일정하지 않은 튜플에 사용하면 상당히 편리하다
--------------------------------------------------------------------------------------
'''

records = [('foo', 1, 2), ('bar', 'hello'), ('foo', 3, 4)]

def do_foo(x, y):
    print('foo', x, y)

def do_bar(s):
    print('bar', s)

for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)

'''
--------------------------------------------------------------------------------------
- 문자열 프로세싱에 사용해도 편리하다
--------------------------------------------------------------------------------------
'''

line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
uname, *fields, homedir, sh = line.split(':')

print(uname)
print(homedir)
print(sh)

'''
--------------------------------------------------------------------------------------
- ign(ignored)

    언패킹 이후에 특정 값을 버리고 싶을 때 언패킹에 별표(*)만 따로 쓸 수 없지만
    버리기용 변수명을 그대로 사용할 수 있다
--------------------------------------------------------------------------------------
'''

record = ('ACME', 50, 123.45, (12, 18, 2012))
name, *_, (*_, year) = record

print(name)
print(year)

'''
--------------------------------------------------------------------------------------
- 리스트가 있을 때 머리와 꼬리 부분으로 분리 할 수 있다
--------------------------------------------------------------------------------------
'''

items = [1, 10, 7, 4, 5, 9]
head, *tail = items

print(head)
print(tail)

'''
--------------------------------------------------------------------------------------
- 재귀 알고리즘을 사용하는 함수 생성
--------------------------------------------------------------------------------------
'''

def sum(items):
    head, *tail = items
    return head + sum(tail) if tail else head

print(sum([1, 10, 7, 4, 5, 9]))





'''
--------------------------------------------------------------------------------------
1.3 마지막 N 개 아이템 유지

문제 : 순환이나 프로세싱 중 마지막으로 발견한 N개의 아이템 유지 (collections, deque)
--------------------------------------------------------------------------------------
'''

from collections import deque

def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)

    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)

'''
--------------------------------------------------------------------------------------
- yield 를 포함한 제너레이터 함수

    아이템을 찾는 코드 작성할 때 사용
    검색 과정과 결과를 사용하는 코드 분리
--------------------------------------------------------------------------------------
'''

from collections import deque

q = deque(maxlen=3)
q.append(1)
q.append(2)
q.append(3)

print(q)

deque([1, 2, 3], maxlen=3)
q.append(4)

print(q)

deque([2, 3, 4], maxlen=3)
q.append(5)

print(q)

deque([3, 4, 5], maxlen=3)


'''
=> deque(maxlen=N)을 고정 크기 큐 생성

=> 큐가 꽉찬 상태에서 새로운 아이템을 넣으면 가장 마지막 아이템이 자동으로 삭제
--------------------------------------------------------------------------------------
'''

from collections import deque

q = deque()
q.append(1)
q.append(2)
q.append(3)

print(q)

'''
=> 일반적으로 큐 구조체가 필요할 때 deque 사용

=> 최대 크기를 지정하지 않으면 제약없이 양쪽에 아이템을 넣거나 빼는 작업을 할 수 있다
--------------------------------------------------------------------------------------
'''

from collections import deque

q = deque([1, 2, 3])

q.appendleft(4)
print(q)

deque([4, 1, 2, 3])

print(q.pop())
print(q)

deque([4, 1, 2])

print(q.popleft())

'''
--------------------------------------------------------------------------------------
=> 큐의 양 끝에 아이템을 넣거나 빼는 작업에는 시간복잡도 O(1)이 소요
   이는 O(N)이 소요되는 리스트의 작업에 비해 훨씬 빠르다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
1.4	N 아이템의 최대 혹은 최소값 찾기

문제 : 컬렉션 내부에서 가장 크거나 작은 N개의 아이템 찾기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- heapq 모듈

	nlargest() 함수		nsmallest() 함수
--------------------------------------------------------------------------------------
'''

import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]

print(heapq.nlargest(3, nums))
print(heapq.nsmallest(3, nums))

'''
--------------------------------------------------------------------------------------
'''

import heapq

portfolio = [{'name': 'IBM', 'shares': 100, 'price': 91.1},
             {'name': 'AAPL', 'shares': 50, 'price': 543.22},
             {'name': 'FB', 'shares': 200, 'price': 21.09},
             {'name': 'HPQ', 'shares': 35, 'price': 31.75},
             {'name': 'YHOO', 'shares': 45, 'price': 16.35},
             {'name': 'ACME', 'shares': 75, 'price': 115.65}]

cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])

print(cheap)
print(expensive)

'''
--------------------------------------------------------------------------------------
- 가장 작거나 큰 N개의 아이템을 찾고 있고 N이 컬렉션 전체 크기보다 작다면 앞에 나온 함수가
  더 나은 성능을 제공 
--------------------------------------------------------------------------------------
'''

import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
heap = list(nums)
heapq.heapify(heap)

print(heap)

'''
--------------------------------------------------------------------------------------
- 힙의 가장 중요한 기능은 바로 heap[0]이 가장 작은 아이템
  힙의 첫 아이템을 팝하고 그 다음 아이템으로 치환하는 heapq.heappop() 메소드 사용
--------------------------------------------------------------------------------------
'''

import heapq

nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
heap = list(nums)
heapq.heapify(heap)

print(heapq.heappop(heap))
print(heapq.heappop(heap))
print(heapq.heappop(heap))

'''
--------------------------------------------------------------------------------------
- nlargest()와 nsmallest() 함수는 찾고자 하는 아이템의 개수가 상대적으로 작을 때 가장 알맞다
  만약 최소값이나 최대값을 구하려 한다면(N이 1), min()과 max()를 사용하는 것이 더 빠르다

- N의 크기가 컬렉션 크기와 비슷해지면 우선 컬렉션을 정렬해서 그 조각을 사용하는 것이 더 빠르다
  (sorted(items)[:N] 이나 sorted(items)[-N:] 사용)
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
1.5 우선 순위 큐 구현

문제 : 주어진 우선 순위에 따라 아이템을 정렬하는 큐를 구현하고 항상 우선 순위가 가장 높은
      아이템을 먼저 팝하도록 구현
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- heapq 모듈을 사용해 간단한 우선 순위 큐 생성
--------------------------------------------------------------------------------------
'''

import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]

class Item:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'Item({!r})'.format(self.name)

q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)

print(q.pop())
print(q.pop())
print(q.pop())
print(q.pop())

'''
--------------------------------------------------------------------------------------
- heapq.heappush() 와 heap.heappop() 은 list_queue의 첫번째 아이템이 가장 작은 우선 순위를 
  가진 것 처럼 아이템을 삽입하거나 제거한다

- heappop() 메소드는 항상 작은 아이템을 반환해서 큐의 팝이 올바른 아이템에 적용될 수 있도록 한다

- 크기가 N일 때 푸시와 팝의 시간복잡도가 O(logN) 이므로 N이 아주 커진다 해도 상당히 효율적

--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 순서를 매길 수 없는 Item 인스턴스
--------------------------------------------------------------------------------------
'''

import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]

class Item:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'Item({!r})'.format(self.name)

q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)

a = Item('foo')
b = Item('bar')

a < b

'''
--------------------------------------------------------------------------------------
=> Traceback (most recent call last):
   File "D:/python/Source/cookbook/1. 자료구조와 알고리즘.py", line 246, in <module>
    a < b
   TypeError: '<' not supported between instances of 'Item' and 'Item'

--------------------------------------------------------------------------------------
'''

import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]

class Item:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'Item({!r})'.format(self.name)

q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)

a = (1, Item('foo'))
b = (5, Item('bar'))

print(a < b)

c = (1, Item('grok'))

print(a < c)

'''
=> TypeError: '<' not supported between instances of 'Item' and 'Item'

=> 우선 순위 값이 달라야만 비교가 가능하다!!
--------------------------------------------------------------------------------------
'''

import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]

class Item:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'Item({!r})'.format(self.name)

q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)

a = (1, 0, Item('foo'))
b = (5, 1, Item('bar'))
c = (1, 2, Item('grok'))

print(a < b)
print(a < c)





'''
--------------------------------------------------------------------------------------
1.6	딕셔너리의 키를 여러 값에 매핑하기

문제 : 딕셔너리의 키를 하나 이상의 값에 매핑하기(multidict)
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 딕셔너리

    하나의 키에 하나의 값이 매핑되어 있는 것
    키에 여러 값을 매핑하려면 그 여러 값을 리스트나 세트와 같은 컨테이너에 따로 저장
    
- 리스트나 세트 사용 여부는 사용 목적에 따라 달라진다
  
- 아이템의 삽입 순서를 지켜야 한다면 리스트를 사용하는 것이 좋고 순서가 상관없이 중복을 없애려면
  세트를 사용해야 한다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- collections 모듈의 defaultdict

    첫번째 값을 자동으로 초기화하는 것이 있어서 사용자는 아이템 추가에만 집중할 수 있다
--------------------------------------------------------------------------------------
'''

from collections import defaultdict

d = defaultdict(list)
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)

print(d)

d = defaultdict(set)
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)

print(d)

'''
--------------------------------------------------------------------------------------
- 다만 defaultdict를 사용할 때는 딕셔너리에 존재하지 않는 값이라도 한번이라도 있었던 키의
  엔트리를 자동으로 생성한다는 점을 주의!
  
- 이런 동작성이 마음에 들지 않는다면 일반 딕셔너리 setdefault() 사용
--------------------------------------------------------------------------------------
'''

d = {}
d.setdefault('a', []).append(1)
d.setdefault('a', []).append(2)
d.setdefault('b', []).append(4)

print(d)





'''
--------------------------------------------------------------------------------------
1.7	딕셔너리 순서 유지

문제 : 딕셔너리를 만들고 순환이나 직렬화할 때 순서 조절
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 딕셔너리 내부 아이템의 순서를 조절하려면 collections 모듈의 OrderedDice 사용
  (삽입 초기의 순서를 그대로 기억)
--------------------------------------------------------------------------------------
'''

from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

for key in d:
    print(key, d[key])

'''
--------------------------------------------------------------------------------------
- 직렬화하거나 다른 포멧으로 인코딩할 다른 매핑을 만들 때 특히 유용
  JSON 인코딩에 나타나는 특정 필드의 순서를 조절하기 위해서 OrderedDict 사용
--------------------------------------------------------------------------------------
'''

from collections import OrderedDict
import json

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

print(json.dumps(d))

'''
--------------------------------------------------------------------------------------
- OrdereDict 는 내부적으로 더블 링크드 리스트로 삽입 순서와 관련있는 키를 기억한다
  새로운 아이템을 처음으로 삽입하면 리스트의 제일 끝에 위치시킨다.
  기존 키에 재할당을 한다 해도 순서에는 변화가 생기지 않는다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
1.8 딕셔너리 계산

문제 : 딕셔너리 데이터에 여러 계산을 수행 (최소값, 최대값, 정렬 등)
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 딕셔너리에 주식 이름과 가격이 들어있다고 가정
  딕셔너리 내용에 대해 유용한 계산을 하려면 딕셔너리의 키와 값을 zip() 으로 뒤집는 것이 좋다
  최소 주가와 최대 주가 찾는 코드
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

min_price = min(zip(prices.values(), prices.keys()))
max_price = max(zip(prices.values(), prices.keys()))

print(min_price)
print(max_price)

'''
--------------------------------------------------------------------------------------
- 데이터의 순서를 매기려면 zip() 과 sorted() 사용
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

min_price = min(zip(prices.values(), prices.keys()))
max_price = max(zip(prices.values(), prices.keys()))
prices_sorted = sorted(zip(prices.values(), prices.keys()))

print(prices_sorted)

'''
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

min_price = min(zip(prices.values(), prices.keys()))
max_price = max(zip(prices.values(), prices.keys()))
prices_sorted = sorted(zip(prices.values(), prices.keys()))
prices_and_names = zip(prices.values(), prices.keys())

print(min(prices_and_names))
print(max(prices_and_names))

'''
=> (10.75, 'FB')

=> Traceback (most recent call last):
   File "D:/python/Source/cookbook/1. 자료구조와 알고리즘.py", line 320, in <module>
   print(max(prices_and_names))
   ValueError: max() arg is an empty sequence

=> 계산을 할 때 zip()은 단 한 번만 소비할 수 있는 이터레이터(iterator)를 생성
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 딕셔너리에서 일반적으로 데이터 축소를 시도하면, 오직 키에 대해서만 작업이 이루어진다
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

print(min(prices))
print(max(prices))

'''
--------------------------------------------------------------------------------------
- 딕셔너리의 값에 대한 계산을 위해서는 딕셔너리의 value() 메소드 사용
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

print(min(prices.values()))
print(max(prices.values()))

'''
--------------------------------------------------------------------------------------
- 키에 일치하는 값 정보까지 알고 싶을 때
  최소, 최대값에 일치하는 키를 찾으려면 min() 과 max()에 키 함수 제공
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

print(min(prices, key=lambda k:prices[k]))
print(max(prices, key=lambda k:prices[k]))

'''
--------------------------------------------------------------------------------------
- 최소값을 얻기 위해서는 한 번 더 살펴보는 작업
--------------------------------------------------------------------------------------
'''

prices = {'ACME': 45.23, 'AAPL': 612.78,
          'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75}

min_value = prices[min(prices, key=lambda k:prices[k])]

print(min_value)





'''
--------------------------------------------------------------------------------------
1.9 두 딕셔너리의 유사점 찾기

문제 : 두 딕셔너리가 있고 여기서 유사점 찾기 (동일한 키 , 동일한 값 등)
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 두 딕셔너리의 유사점을 찾으려면 keys() 와 items() 메소드에 집합 연산 수행
--------------------------------------------------------------------------------------
'''

a = {'x':1, 'y':2, 'z':3}
b = {'w':10, 'x':11, 'y':2}

print(a.keys() & b.keys())
print(a.keys() - b.keys())
print(a.items() & b.items())

'''
--------------------------------------------------------------------------------------
- 딕셔너리의 keys() 메소드는 키-뷰(key-view) 객체 반환

- 딕셔너리 키에 집합 연산을 수행하려면 변환할 필요 없이 키-뷰 객체를 바로 사용

- 딕셔너리의 items() 메소드는 (key, value) 페어로 구성된 아이템-뷰(item-view) 변환

- 이 객체는 집합 연산과 유사한 것을 지원하므로 두 딕셔너리에 동일한 

- value() 메소드는 앞에 나온 집합 연산을 지원하지 않는다
  다르게 값-뷰는 유일하다는 보장이 없기 때문, 이사실만으로도 특정 집합
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
1.10 순서를 깨지 않고 시퀀스의 중복 없애기

문제 : 시퀀스에서 중복된 값을 없애고 싶지만, 아이템의 순서는 유지
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 시퀀스의 값이 해시(hash) 가능하다면 이 문제는 세트와 제너레이터(generator) 사용
--------------------------------------------------------------------------------------
'''

def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)

a = [1, 5, 2, 1, 9, 1, 5, 10]

print(list(dedupe(a)))

'''
--------------------------------------------------------------------------------------
- 시퀀스의 아이템이 해시 가능한 경우에만 사용할 수 있다. 해시 불가능 타입의 중복을 없애기
--------------------------------------------------------------------------------------
'''

def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)

a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]

print(list(dedupe(a, key=lambda d: (d['x'],d['y']))))
print(list(dedupe(a, key=lambda d: d['x'])))

'''
--------------------------------------------------------------------------------------
- 중복을 없애려면 대개 세트를 만드는 것이 가장 쉽다
--------------------------------------------------------------------------------------
'''

a = [1, 5, 2, 1, 9, 1, 5, 10]

print(set(a))





'''
--------------------------------------------------------------------------------------
1.11 슬라이스 이름 붙이기

문제 : 프로그램 코드에 슬라이스(slice)를 지시하는 하드코딩이 너무 많아 이해하기 어려워서 정리
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 내장 함수인 slice()는 슬라이스 받는 모든 곳에 사용할 수 있는 조각 생성
--------------------------------------------------------------------------------------
'''

items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2, 4)

print(items[2:4])
print(items[a])

items[a] = [10,11]

print(items)

del items[a]
print(items)

'''
--------------------------------------------------------------------------------------
- slice 인스턴스 s가 있다면 s.start와 s.stop, s.step 속성 확인
--------------------------------------------------------------------------------------
'''

a = slice(10, 50, 2)

print(a.start)
print(a.stop)
print(a.step)

'''
--------------------------------------------------------------------------------------
- indices(size) 메소드를 사용하면 특정 크기의 시퀀스에 슬라이스를 매핑할 수 있다
  (튜플(start, stop, step)을 반환하는데 모든 값은 경계를 넘어서지 않도록 제약이 걸려있다)
--------------------------------------------------------------------------------------
'''

a = slice(5, 10, 2)
s = 'HelloWorld'

print(a.indices(len(s)))

for i in range(*a.indices(len(s))):
    print(s[i])





'''
--------------------------------------------------------------------------------------
1.12 시퀀스에 가장 많은 아이템 찾기

문제 : 시퀀스에 가장 많이 나타난 아이템 찾기
--------------------------------------------------------------------------------------
'''

from collections import Counter

words = ['look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
         'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
         'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
         'my', 'eyes', "you're", 'under']

word_counts = Counter(words)
top_three = word_counts.most_common(3)

print(top_three)

'''
--------------------------------------------------------------------------------------
- Counter 객체에는 해시 가능한 모든 아이템 입력 가능
  (Counter : 아이템이 나타난 횟수를 가리키는 딕셔너리)
--------------------------------------------------------------------------------------
'''

from collections import Counter

words = ['look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
         'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
         'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
         'my', 'eyes', "you're", 'under']

word_counts = Counter(words)

print(word_counts['not'])
print(word_counts['eyes'])

'''
--------------------------------------------------------------------------------------
- 카운트를 수동으로 증가시키고 싶다면 단순하게 더하기 사용
--------------------------------------------------------------------------------------
'''

from collections import Counter

words = ['look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
         'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
         'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
         'my', 'eyes', "you're", 'under']

word_counts = Counter(words)

for word in words:
    word_counts[word] += 0

print(word_counts['eyes'])

'''
--------------------------------------------------------------------------------------
- Counter 인스턴스에 잘 알려지지 않은 기능으로 여러 가지 수식 사용
--------------------------------------------------------------------------------------
'''

from collections import Counter

words = ['look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
         'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
         'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
         'my', 'eyes', "you're", 'under']

morewords = ['why','are','you','not','looking','in','my','eyes']

a = Counter(words)
b = Counter(morewords)
c = a + b
d = a - b

print(a)
print(b)
print(c)
print(d)





'''
--------------------------------------------------------------------------------------
1.13 일반 키로 딕셔너리 리스트 정렬

문제 : 딕셔너리 리스트가 있고, 하나 혹은 그 이상의 딕셔너리 값으로 정렬
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- operator 모듈의 itemgetter 함수 사용
--------------------------------------------------------------------------------------
'''

from operator import itemgetter

rows = [{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
        {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
        {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
        {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}]

rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))

print(rows_by_fname)
print(rows_by_uid)

'''
--------------------------------------------------------------------------------------
- itemgetter() 함수는 키를 여러 개 전달 가능
--------------------------------------------------------------------------------------
'''

from operator import itemgetter

rows = [{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
        {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
        {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
        {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}]

rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))

print(rows_by_lfname)

'''
--------------------------------------------------------------------------------------
- 키워드 인자 key를 받는 내장 함수 sorted()에 
  Itemgetter() 함수는 그런 호출 가능 객체 생성

- operator, itemgetter() 함수는 rows 레코드에서 원하는 값을 추출하는 데 사용하는 인덱스를 인자로 받는다
  딕셔너리 키 이름이나 숫자 리스트 요소가 될 수도 있고, 객체의 __getitem__() 메소드에 넣을 수 있는 모든 값이 가능

- itemgetter()에 여러 인덱스를 전달하면, 생성할 호출 가능 객체가 모든 요소를 가지고 있는 튜플을 반환하고
  Sorted() 가 튜플의 정렬 순서에 따라 결과의 순서를 잡는다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- itemgetter() 의 기능을 때때로 lamda 표현식으로 대체 가능
--------------------------------------------------------------------------------------
'''

rows = [{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
        {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
        {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
        {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}]

rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))

print(rows_by_fname)
print(rows_by_lfname)

'''
--------------------------------------------------------------------------------------
- min() 과 max() 와 같은 함수에도 사용 가능
--------------------------------------------------------------------------------------
'''

from operator import itemgetter

rows = [{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
        {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
        {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
        {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}]

print(min(rows, key=itemgetter('uid')))
print(max(rows, key=itemgetter('uid')))





'''
--------------------------------------------------------------------------------------
1.14 기본 비교 기능 없이 객체 정렬

문제 : 동일한 클래스 객체를 정렬해야 하는데, 이 클래스는 기본적인 비교 연산을 제공하지 않는다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 내장 함수 sorted()는 key 인자에 호출 가능 객체를 받아 sorted가 객체 비교에 사용할 수 있는 값을 반환
  (User 인스턴스를 입력으로 받고 user_id를 반환하는 코드 작성)
--------------------------------------------------------------------------------------
'''

class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)

users = [User(23), User(3), User(99)]

print(users)
print(sorted(users, key=lambda u: u.user_id))

'''
--------------------------------------------------------------------------------------
- lamda를 사용하는 대신 operator, attrgetter() 사용 가능
--------------------------------------------------------------------------------------
'''

from operator import attrgetter

class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)

users = [User(23), User(3), User(99)]

print(sorted(users, key=attrgetter('user_id')))

'''
--------------------------------------------------------------------------------------
- min() 과 max() 같은 함수에 사용 가능
--------------------------------------------------------------------------------------
'''

from operator import attrgetter

class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)

users = [User(23), User(3), User(99)]

print(min(users, key=attrgetter('user_id')))
print(max(users, key=attrgetter('user_id')))





'''
--------------------------------------------------------------------------------------
1.15 필드에 따라 레코드 묶기

문제 : 일련의 딕셔너리나 인스턴스가 있고 특정 필드 값에 기반한 그룹의 데이터를 
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- itertools.groupby() 함수는 데이터를 묶는데 유용
 (날짜로 구분 지을 데이터 조각을 순환, 우선 원하는 필드에 따라 정렬하고(data 필드), 그 후에 함수 사용)
--------------------------------------------------------------------------------------
'''

from operator import itemgetter
from itertools import groupby

rows = [{'address': '5412 N CLARK', 'date': '07/01/2012'},
        {'address': '5148 N CLARK', 'date': '07/04/2012'},
        {'address': '5800 E 58TH', 'date': '07/02/2012'},
        {'address': '2122 N CLARK', 'date': '07/03/2012'},
        {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
        {'address': '1060 W ADDISON', 'date': '07/02/2012'},
        {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
        {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},]

rows.sort(key=itemgetter('date'))

for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)

'''
--------------------------------------------------------------------------------------
- groupby() 함수는 시퀀스를 검색하고 동일한 값(혹은 키 함수에서 반환한 값)에 대한 일련의 실행을 찾는다
  개별 순환에 대해서 값, 그리고 같은 값을 가진 그룹의 모든 아이템을 만드는 이터레이터(iterator)를 함께 반환

- 원하는 필드에 따라 데이터를 정렬해야 하는 과정이 중요
  Groupby() 함수는 연속된 아이템에만 동작하기 때문에 정렬 과정을 생략하면 원하는 대로 함수 실행 X
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- defaultdict() 사용
--------------------------------------------------------------------------------------
'''

from collections import defaultdict

rows = [{'address': '5412 N CLARK', 'date': '07/01/2012'},
        {'address': '5148 N CLARK', 'date': '07/04/2012'},
        {'address': '5800 E 58TH', 'date': '07/02/2012'},
        {'address': '2122 N CLARK', 'date': '07/03/2012'},
        {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
        {'address': '1060 W ADDISON', 'date': '07/02/2012'},
        {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
        {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},]

rows_by_date = defaultdict(list)

for row in rows:
    rows_by_date[row['date']].append(row)

for r in rows_by_date['07/01/2012']:
    print(r)





'''
--------------------------------------------------------------------------------------
1.16 시퀀스 필터링

문제 : 시퀀스 내부에 데이터가 있고 특정 조건에 따라 값을 추출하거나 줄이기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 리스트 컴프리헨션 (list comprehension)
--------------------------------------------------------------------------------------
'''

mylist = [1, 4, -5, 10, -7, 2, 3, -1]

print([n for n in mylist if n > 0])
print([n for n in mylist if n < 0])

'''
--------------------------------------------------------------------------------------
- 생성자 표현식 사용
--------------------------------------------------------------------------------------
'''

mylist = [1, 4, -5, 10, -7, 2, 3, -1]

pos = (n for n in mylist if n > 0)

print(pos)

for x in pos:
    print(x)

'''
--------------------------------------------------------------------------------------
- 필터링 도중에 예외 처리를 해야 한다거나 다른 복잡한 내용이 들어가야 한다면 filter() 사용
  (filter() 는 이터레이터(iterator) 생성, 따라서 결과의 리스트를 만들고 싶다면 list()도 함께 사용)
--------------------------------------------------------------------------------------
'''

values = ['1', '2', '-3', '-', '4', 'N/A', '5']

def is_int(val):
    try:
        x = int(val)
        return True

    except ValueError:
        return False

ivals = list(filter(is_int, values))

print(ivals)

'''
--------------------------------------------------------------------------------------
- 리스트 컴프리헨션과 생성자 표현식은 간단한 데이터를 걸러 내기 위한 가장 쉽고 직관적 방법
  (동시에 데이터 변형 기능)
--------------------------------------------------------------------------------------
'''

import math

mylist = [1, 4, -5, 10, -7, 2, 3, -1]

print([math.sqrt(n) for n in mylist if n > 0])

'''
--------------------------------------------------------------------------------------
- 필터링에는 조건을 만족하지 않는 값을 걸러 내는 것 외에도 새로운 값으로 치환하는 방식
  (리스트에서 양수만 찾아내는 필터링뿐 아니라 잘못된 값을 특정 범위에 들어가도록 수정할 수도 있고,
   필터링 조건을 조건 표현식으로 바꿔 주면 간단히 해결)
--------------------------------------------------------------------------------------
'''

mylist = [1, 4, -5, 10, -7, 2, 3, -1]

clip_neg = [n if n > 0 else 0 for n in mylist]
clip_pos = [n if n < 0 else 0 for n in mylist]

print(clip_neg)
print(clip_pos)

'''
--------------------------------------------------------------------------------------
- 순환 가능한 것과 Boolean 셀렉터 시퀀스
  (카운트 값이 5 이상인 주소만)
--------------------------------------------------------------------------------------
'''

from itertools import compress

addresses = ['5412 N CLARK', '5148 N CLARK', '5800 E 58TH',
             '2122 N CLARK', '5645 N RAVENSWOOD', '1060 W ADDISON',
             '4801 N BROADWAY', '1039 W GRANVILLE']

counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
more5 = [n > 5 for n in counts]

print(more5)
print(list(compress(addresses, more5)))

'''
--------------------------------------------------------------------------------------
=> 우선 주어진 조건에 만족하는지 여부를 담은 Boolean 시퀀스를 만들어 두는 것이
   그리고 compress() 함수로 True에 일치하는 값만 골라낸다

=> filter() 와 마찬가지로 compress()는 일반적으로 이터레이터를 반환
   따라서 결과를 리스트에 담고 싶다면 list() 사용
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
=> 우선 주어진 조건에 만족하는지 여부를 담은 Boolean 시퀀스를 만들어 두는 것이
   그리고 compress() 함수로 True에 일치하는 값만 골라낸다

=> filter() 와 마찬가지로 compress()는 일반적으로 이터레이터를 반환
   따라서 결과를 리스트에 담고 싶다면 list() 사용
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
1.17 딕셔너리의 부분 추출

문제 : 딕셔너리의 특정 부분으로부터 다른 딕셔너리 만들기
--------------------------------------------------------------------------------------
'''

'''
---------------------------------------------------------------------------------------
- 딕셔너리 컴프리헨션(dictionary comprehension)을 사용하면 간단하게 해결
---------------------------------------------------------------------------------------
'''

prices = { 'ACME' : 45.23, 'AAPL' : 612.78, 'IBM' : 205.55,
          'HPQ' : 37.20, 'FB' : 10.75}

tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}

p1 = {key:value for key, value in prices.items() if value > 200}
p2 = {key:value for key, value in prices.items() if key in tech_names}

print(p1)
print(p2)