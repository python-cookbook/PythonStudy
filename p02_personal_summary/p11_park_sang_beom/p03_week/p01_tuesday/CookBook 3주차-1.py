'''
--------------------------------------------------------------------------------------
4.7 이터레이터의 일부 얻기

문제 : 이터레이터가 만드는 데이터의 일부를 얻고 싶지만, 일반적인 자르기 연산자가 동작하지 않는다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 이터레이터와 제너레이터의 일부를 얻는 데는 itertools.islice() 함수 사용
--------------------------------------------------------------------------------------
'''

def count(n):
    while True:
        yield n
        n += 1

c = count(0)

print(c[10:20])     # 에러

# islice() 사용
import itertools

def count(n):
    while True:
        yield n
        n += 1

c = count(0)

for x in itertools.islice(c, 10, 20):
    print(x)

'''
=> 이터레이터와 제너레이터는 일반적으로 일부를 잘라낼 수 없다!
   왜냐하면 데이터의 길이를 알 수 없기 때문이다

=> islice()의 실행 결과는 원하는 아이템의 조각을 생성하는 이터레이터지만, 이는 시작 인덱스까지
   모든 아이템을 소비하고 버리는 식으로 수행 그리고 그 뒤의 아이템은 마지막 인덱스를
   만날 때까지 islice 객체가 생성

=> 주어진 이터레이터 상에서 islice()가 데이터를 소비한다는 점이 중요하다
   이터레이터를 뒤로 감을 수 없기 때문에 이 부분을 고려
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.8 순환 객체 첫번째 부분 건너뛰기

문제 : 순환 객체의 아이템을 순환하려고 하는데, 처음 몇 가지 아이템에는 관심이 없어서 건너뛰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- itertools 모듈의 itertools.dropwhile() 함수
  
  반환된 이터레이터는 넘겨준 함수가 True를 반환하는 동안은  시퀀스의 첫번째 아이템을 무시, 그후에는
  전체 시퀀스 생성
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 만약 어디까지 생략해야 할지 정확한 숫자를 알고 있다면 itertools.islice() 함수 사용
--------------------------------------------------------------------------------------
'''

from itertools import islice

items = ['a', 'b', 'c', 1, 4, 10, 15]

for x in islice(items, 3, None):
    print(x)

'''
=> islice()에 전달한 마지막 None 인자는 처음 세 아이템 뒤에 오는 모든 것을 원함
   [:3] 이 아니라 [3:] 
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.9 가능한 모든 순열과 조합 순환

문제 : 아이템 컬렉션에 대해 가능한 모든 순열과 조합 순환하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- itertools 모듈의 itertools.permutations()로 아이템 컬렉션을 받아 가능한 모든 순열을 튜플 시퀀스로 생성
--------------------------------------------------------------------------------------
'''

from itertools import permutations

items = ['a', 'b', 'c']

for p in permutations(items):
    print(p)

'''
--------------------------------------------------------------------------------------
- 만약 더 짧은 길이의 순열을 원한다면 선택적으로 길이 인자 지정
--------------------------------------------------------------------------------------
'''

from itertools import permutations

items = ['a', 'b', 'c']

for p in permutations(items, 2):
    print(p)

'''
--------------------------------------------------------------------------------------
- 입력 받은 아이템의 가능한 조합을 생성하기 위해서 itertools.combinaions() 함수 사용
--------------------------------------------------------------------------------------
'''

from itertools import combinations

items = ['a', 'b', 'c']

for c in combinations(items, 3):
    print(c)

for c in combinations(items, 2):
    print(c)

for c in combinations(items, 1):
    print(c)

'''
=> combinations()의 경우 실제 요소의 순서는 고려하지 않는다
   조합을 생성할 때, 선택한 아이템은 가능한 후보의 컬렉션에서 제거된다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 같은 아이템을 두 번 이상을 선택하려면 itertools.combinations_with_replacement() 함수 사용
--------------------------------------------------------------------------------------
'''

import itertools

items = ['a', 'b', 'c']

for c in itertools.combinations_with_replacement(items, 3):
    print(c)





'''
--------------------------------------------------------------------------------------
4.10 인덱스-값 페어 시퀀스 순환

문제 : 시퀀스를 순환하려고 한다. 이때 어떤 요소를 처리하고 있는지 번호 알기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- enumerate() 함수 사용
--------------------------------------------------------------------------------------
'''

my_list = ['a', 'b', 'c']

for idx, val in enumerate(my_list):
    print(idx, val)


# 출력 시 번호를 1번부터 시작하고 싶으면 start 인자 사용
my_list = ['a', 'b', 'c']

for idx, val in enumerate(my_list, 1):
    print(idx, val)


# 에러 메시지에 파일의 라인 번호 저장
def parse_data(filename):
    with open(filename, 'rt') as f:
        for lineno, line in enumerate(f, 1):
            fields = line.split()
            try:
                count = int(fields[1])

            except ValueError as e:
                print('Line {}: parse error: {}'.format(lineno, e))

'''
--------------------------------------------------------------------------------------
- enumerate()는 특정 값의 출현을 위한 오프셋(offset) 추적에 활용 
--------------------------------------------------------------------------------------
'''

from collections import defaultdict

word_summary = defaultdict(list)

with open('myfile_txt', 'r') as f:
    lines = f.readline()

for idx, line in enumerate(lines):
    words = [w.strip().lower() for w in line.split()]
    for word in words:
        word_summary[word].append(idx)


'''
--------------------------------------------------------------------------------------
- enumerate()가 반환하는 값은 연속된 튜플을 반환하는 이터레이터인 enumerate() 객체의 인스턴스
 
- 이 튜플은 전달한 시퀀스에 next() 를 호출해 반환된 카운터와 값으로 이루어져 있다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 실수 주의!! 
--------------------------------------------------------------------------------------
'''

data = [(1,2), (3,4), (5,6), (7,8)]

for n, (x,y) in enumerate(data):
    print(n, (x,y))





'''
--------------------------------------------------------------------------------------
4.11 여러 시퀀스 동시에 순환

문제 : 여러 시퀀스에 들어 있는 아이템을 동시에 순환하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 여러 시퀀스를 동시에 순환하려면 zip() 함수 사용
--------------------------------------------------------------------------------------
'''

xpts = [1, 5, 4, 2, 10, 7]
ypts = [101, 78, 37, 15, 62, 99]

for x, y in zip(xpts, ypts):
    print(x, y)

'''
--------------------------------------------------------------------------------------
- zip(a,b)는 tuple(x,y)를 생성하는 이터레이터 생성
--------------------------------------------------------------------------------------
'''

a = [1, 2, 3]
b = ['w', 'x', 'y', 'z']

for i in zip(a,b):
    print(i)

'''
=> 순환의 길이는 입력된 시퀀스 중 짧은 것과 같다!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 위의 문제를 해결하려면 itertools.zip_longest() 사용
--------------------------------------------------------------------------------------
'''

from itertools import zip_longest

a= [1, 2, 3]
b = ['w', 'x', 'y', 'z']

for i in zip_longest(a, b):
    print(i)

for i in zip_longest(a, b, fillvalue=0):
    print(i)

'''
--------------------------------------------------------------------------------------
- zip() 은 데이터를 묶어야 할 때 주로 사용

- zip()을 사용하면 두 값을 묶어 딕셔너리로 만들 수 있다 
  zip()을 사용하면 시퀀스를 두 개 이상 입력할 수 있다
  zip()이 결과적으로 이터레이터를 생성!
--------------------------------------------------------------------------------------
'''

headers = ['name', 'shares', 'price']
values = ['ACME', 100, 490.1]

s = dict(zip(headers, values))

for name, val in zip(headers, values):
    print(name, '=', val)


a = [1, 2, 3]
b = [10, 11, 12]
c = ['x', 'y', 'z']

for i in zip(a, b, c):
    print(i)

print(list(zip(a, b)))





'''
--------------------------------------------------------------------------------------
4.12 서로 다른 컨테이너 아이템 순환

문제 : 여러 객체에 동일한 작업을 수행해야 하지만, 객체가 서로 다른 컨테이너에 들어 있지만 중첩된 반복문을
      사용해 코드의 가독성을 해치지 않기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 순환 가능한 객체를 리스트로 받고 마스킹을 통해 한번에 순환할 수 있는 itertools.chain() 함수 사용
--------------------------------------------------------------------------------------
'''

from itertools import chain

a = [1, 2, 3, 4]
b = ['x', 'y', 'z']

for x in chain(a, b):
    print(x)

'''
--------------------------------------------------------------------------------------
- chain()은 일반적으로 모든 아이템을 동일한 작업을 수행하고 싶지만 이 아이템이 서로 다른 세트에 포함되어
  있을 때 사용
--------------------------------------------------------------------------------------
'''

# 여러 아이템 세트
active_items = set()
inactive_items = set()


# 모든 아이템 한번에 순환
for item in chain(active_items, inactive_items):
    print(item)

'''
--------------------------------------------------------------------------------------
- itertools.chain() 은 하나 혹은 그 이상의 순환 객체를 인자로 받는다
  그리고 입력 받은 순환 객체 속 아이템을 차례대로 순환하는 이터레이터 생성
  
- 입력한 시퀀스의 크기가 아주 크다면 chain()을 사용하는 것이 메모리 측면에서 유리하고
  타입이 다른 경우에도 쉽게 사용 가능
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.13 데이터 처리 파이프라인 생성

문제 : 데이터 처리를 데이터 처리 파이프라인과 같은 방식으로 순차적으로 처리
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 제너레이터 함수를 사용하는 것이 처리 파이프라인 구현하기 좋다

- 특정 작업 처리를 수행하는 작은 제너레이터 함수의 컬랙션 정의
--------------------------------------------------------------------------------------
'''

import os
import fnmatch
import gzip
import bz2
import re

def gen_find(filepat, top):
    '''
    디렉터리 트리에서 와일드카드 패턴에 매칭하는 모든 파일 이름을 찾는다
    '''
    for path, dirlist, filelist in os.walk(top):
        for name in fnmatch.filter(filelist, filepat):
            yield os.path.join(path, name)

def gen_opener(filenames):
    '''
    파일 이름 시퀀스를 하나씩 열어 파일 객체를 생성
    다음 순환으로 넘어가는 순간 파일을 닫는다
    '''
    for filename in filenames:
        if filename.endswitch('.gz'):
            f = gzip.open(filename, 'rt')
        elif filename.endswitch('.bz2'):
            f = bz2.open(filename, 'rt')
        else:
            f = open(filename, 'rt')
        yield f
        f.close()

def gen_concatenate(iterators):
    '''
    이터레이터 시퀀스를 합쳐 하나의 시퀀스로 만든다
    '''
    for it in iterators:
        yield  from it

def gen_grep(pattern, lines):
    '''
    라인 시퀀스에서 정규식 패턴을 살펴본다
    '''
    pat = re.compile(pattern)
    for line in lines:
        if pat.search(line):
            yield line

lognames = gen_find('access-log', 'www')
files = gen_opener(lognames)
lines = gen_concatenate(files)
pylines = gen_grep('(?i)python', lines)
bytecolumn = (line.rsplit(None,1)[1] for line in pylines)
bytes = (int(x) for x in bytecolumn if x != '-')

print('Total', sum(bytes))

'''
=> 각 제너레이터 함수를 작게 모듈화할 수 있다!

=> 파이프라인 방식을 따르면 메모리 효율성도 높다!
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.14 중첩 시퀀스 풀기

문제 : 중첩된 시퀀스를 합쳐 하나의 리스트로 만들기기
-------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- yield from 문이 있는 재귀 제너레이터를 만들어 해결
--------------------------------------------------------------------------------------
'''

from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

item = [1, 2, [3, 4, [5, 6], 7], 8]

for x in flatten(items):
    print(x)

items = ['Dave', 'Paula', ['Thomas', 'Lewis']]

for x in flatten(items):
    print(x)

'''
=> instance(x, Iterable) 은 아이템이 순환 가능한 것인지 확인
   순환이 가능하다면 yield from 으로 모든 값ㅇ르 하나의 서브루틴으로 분출
   결과적으로 중첩되지 않은 시퀀스 하나가 만들어진다!
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.15 정렬된 여러 시퀀스를 병합 후 순환

문제 : 정렬된 시퀀스가 여럿 있고, 이들을 하나로 합친 후 정렬된 시퀀스 순환
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- heapq.merge() 함수 사용
--------------------------------------------------------------------------------------
'''

import heapq

a = [1, 4, 7, 10]
b = [2, 5, 6, 11]

for c in heapq.merge(a,b):
    print(c)

'''
=> heapq.merge는 아이템에 순환적으로 접근하면 제공한 시퀀스를 한꺼번에 읽지 않는다
   따라서 아주 긴 시퀀스도 별다른 무리 없이 사용가능!
   
=> heapq.merge()에 넣은 시퀀스는 모두 정렬되어 있어야 한다!
   이 함수에 전달한다고 우선적으로 정렬을 하지 않는다
   또한 입력된 데이터가 정렬되어 있는지 확인하지도 않는다
   단지 앞에서부터 읽어 가면서 가장 작은 것부터 데이터를 출력할 뿐
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.16 무한 while 순환문을 이터레이터로 치환

문제 : 함수나 일반적이지 않은 조건 테스트로 인해 무한 while 순환문으로 데이터에 접근하는 코드 작성
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 입출력과 관련 있는 프로그램에 다음과 같은 코드 사용
--------------------------------------------------------------------------------------
'''

CHUKSIZE = 8192

def reader(s):
    for chunk in iter(lambda: s.recv(CHUKSIZE), b''):
        pass
        # process_data(data)

'''
=> 내장 함수 iter()는 선택적으로 인자 없는 호출 가능 객체와 종료 값을 입력 받는다

=> 주어진 종료 값을 반환하기 전까지 무한히 반복해서 호출 가능 객체 호출출
-------------------------------------------------------------------------------------
'''