'''
--------------------------------------------------------------------------------------
Chapter 5 파일과 입출력
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
5.1 텍스트 데이터 읽고 쓰기

문제 : 텍스트 데이터를 읽거나 써야 하는데 ASCII, UTF-8, UTF-16과 같이 서로 다른 인코딩 사용하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 텍스트 파일을 읽기 위해 open() 함수에 rt 모드 사용
--------------------------------------------------------------------------------------
'''

# 파일 전체를 하나의 문자열로 읽기
with open('e:\data\somefile.txt', 'rt') as f:
    data = f.read()
    print(data)

# 파일의 줄을 순환
with open('e:\data\somefile.txt', 'rt') as f:
    for line in f:
        print(line)

# 텍스트 데이터 쓰기
with open('e:\data\somefile.txt', 'wt') as f:
    f.write()
    f.write()

# 리다이렉트한 print 문
with open('e:\data\somefile.txt', 'wt') as f:
    print(line, file=f)
    print(line, file=f)

'''
--------------------------------------------------------------------------------------
- 파일의 끝에 내용을 추가하려면 at 모드로 open() 사용

- 기본적으로 파일을 읽고 쓸 때 sys.getdefaultencoding() 으로 확인할 수 있는 시스템 기본 인코딩 사용
  with open('d:\data\somefile.txt', 'rt', encoding='latin-1') as f:
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- with 문이 파일을 사용할 콘텍스트를 만든다. 컨트롤이 with 블록을 떠나면 파일이 자동으로 닫힌다
  with 문을 꼭 사용하지 않아도 되지만 그럴 때는 반드시 파일을 닫아야 한다
--------------------------------------------------------------------------------------
'''

f = open('e:\data\somefile.txt', 'rt')
data = f.read()
f.close()

'''
--------------------------------------------------------------------------------------
- 줄바꿈
--------------------------------------------------------------------------------------
'''

# 줄바꿈 변환 없이 읽기
with open('e:\data\somefile.txt', 'rt', newline='') as f:
    data = f.read()
    print(data)

# 줄바꿈 변환 사용(기본)
f = open('e:\data\somefile.txt', 'rt')

print(f.read())

# 줄바꿈 변환 미사용
g = open('e:\data\somefile.txt', 'rt', newline='')

print(g.read())

'''
--------------------------------------------------------------------------------------
- 인코딩 에러의 일반적인 에러 처리 방식
--------------------------------------------------------------------------------------
'''

# 알 수 없는 문자를 유니코드 U+fffd로 치환
f = open('e:\data\somefile.txt', 'rt', encoding='ascii', errors='replace')

print(f.read())

# 알 수 없는 문자를 무시
g = open('e:\data\somefile.txt', 'rt', encoding='ascii', errors='ignore')

print(f.read())





'''
--------------------------------------------------------------------------------------
5.2 파일에 출력

문제 : print() 함수의 결과를 파일에 출력하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- print()에 file 키워드 인자 사용
--------------------------------------------------------------------------------------
'''

with open('e:\data\somefile.txt', 'rt') as f:
    print('Hello World!', file=f)

'''
=> 파일을 텍스트 모드로 열었는지 꼭 확인해야 한다
   바이너리 모드로 파일을 열면 출력에 실패
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.3 구별자나 종단 부호 바꾸기

문제 : print()를 사용해 데이터를 출력할 때 구분자나 종단 부호(line ending) 바꾸기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- print() 에 sep 과 end 키워드 인자 사용
--------------------------------------------------------------------------------------
'''

print('ACME', 50, 91.5)

print('ACME', 50, 91.5, sep=',')

print('ACME', 50, 91.5, sep=',', end='!!\n')

'''
--------------------------------------------------------------------------------------
- 출력의 개행 문자(newline)를 바꿀 때도 end 인자 사용
--------------------------------------------------------------------------------------
'''

for i in range(5):
    print(i, end=' ')

'''
--------------------------------------------------------------------------------------
- str.join() 으로 아이템을 구분하는 문자를 스페이스 공백문 이외로 바꾸기
--------------------------------------------------------------------------------------
'''

a = ('ACME', '50', '91.5')

print(','.join(a))

print(','.join(str(x) for x in a))





'''
--------------------------------------------------------------------------------------
5.4 바이너리 데이터 읽고 쓰기

문제 : 이미지나 사운드 파일 등 바이너리 데이터를 읽고 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- open() 함수에 rb와 wb 모드를 사용해서 바이너리 데이터를 읽거나 쓰기
--------------------------------------------------------------------------------------
'''

# 파일 전체를 하나의 바이트 문자열로 읽기
with open('e:\data\somefile.txt', 'rb') as f:
    data = f.read()
    print(data)

# 바이너리 데이터 파일에 쓰기
with open('e:\data\somefile.txt', 'wb') as f:
    f.write(b'Hello World')

'''
--------------------------------------------------------------------------------------
- 데이터에 인덱스나 순환으로 반환된 값은 바이트 문자열이 아닌 정수 바이트 값이 된다
--------------------------------------------------------------------------------------
'''

# 텍스트 문자열
t = 'Hello World'

print(t[0])

for c in t:
    print(c)

# 바이트 문자열
b = b'Hello World'

print(b[0])

for c in b:
    print(c)

'''
--------------------------------------------------------------------------------------
- 바이너리 모드 파일로부터 텍스트를 읽거나 쓰려면 인코딩이나 디코딩 과정이 꼭 필요하다
--------------------------------------------------------------------------------------
'''

with open('e:\data\somefile.txt', 'rb') as f:
    data = f.read(16)
    text = data.decode('utf-8')

with open('e:\data\somefile.txt' 'wb') as f:
    text = 'Hello World'
    f.write(text.encode('uft-8'))

'''
--------------------------------------------------------------------------------------
- 바이너리 입출력 시 잘 알려지지 않은 기능으로 배열이나 C 구조체와 같은 객체를 bytes 객체로
  변환하지 않고 바로 쓸 수 있다
--------------------------------------------------------------------------------------
'''

import array

nums = array.array('i', [1, 2, 3, 4])

with open('e:\data\somefile.txt', 'wb') as f:
    f.write(nums)

'''
--------------------------------------------------------------------------------------
- readinto() 메소드를 사용하면 여러 객체의 바이너리 데이터를 직접 메모리에 읽어 들일 수 있다
--------------------------------------------------------------------------------------
'''

import array

a = array.array('i', [0,0,0,0,0,0,0,0])

with open('e:\data\somefile.txt', 'rb') as f:
    f.readinto(a)

print(a)





'''
--------------------------------------------------------------------------------------
5.5 존재하지 않은 파일에 쓰기

문제 : 파일이 파일 시스템에 존재하지 않을 때, 데이터를 파일에 쓰기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- open() 에 x모드를 사용해서 해결
--------------------------------------------------------------------------------------
'''

with open('d:\data\somefile.txt', 'wt') as f:
    f.write('Hello\n')

'''
=> 파일이 바이너리 모드이면 xt 대신 xb 사용!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 파일을 쓸 때 발생할 수 있는 문제점(실수로 파일을 덮어쓰는 등)을 아주 우아하게 피해 가는 코드
  혹은 파일을 쓰기 전에 파일이 있는지 확인하는 방법
--------------------------------------------------------------------------------------
'''

import os
if not os.path.exists('d:\data\somefile.txt'):
    with open('d:\data\somefile.txt', 'wt') as f:
        f.write('Hello\n')
else:
    print('File already exists!')

'''
=> 확실히 x 모드를 사용하는 것이 훨씬 깔끔 
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.6 문자열에 입출력 작업하기

문제 : 파일 같은 객체에 동작하도록 작성한 코드에 텍스트나 바이너리 문자열을 제공
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- io.StringIO()와 io.BytesIO() 클래스로 문자열 데이터에 동작하는 파일 같은 객체 생성
--------------------------------------------------------------------------------------
'''

import io

s = io.StringIO()

s.write('Hello World\n')
print('This is a test', file=s)


# 기록한 모든 데이터 얻기
print(s.getvalue())

# 기존 문자열을 파일 인터페이스로 감싸기
s = io.StringIO('Hello\nWorld\n')

print(s.read(4))
print(s.read())

'''
--------------------------------------------------------------------------------------
- io.StringIO() 클래스는 텍스트에서만 사용
  바이너리 데이터를 다룰 때는 io.BytesIO 클래스 사용
--------------------------------------------------------------------------------------
'''

import io

s = io.BytesIO()
s.write(b'binary data')

print(s.getvalue())

'''
--------------------------------------------------------------------------------------
- 유닛 테스트를 할 때, StringIO로 테스트 데이터를 담고 있는 객체를 만들어 일반 파일에 동작하는 함수 사용
  
- StringIO 와 BytesIO 인스턴스가 올바른 정수 파일 디스크립터를 가지고 있지 않다!
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
5.7 압축된 데이터 파일 읽고 쓰기

문제 : gzip 이나 bz2 로 압축한 파일을 읽거나 쓰기 
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- gzip 과 bz2 모듈 사용(open() 을 사용하는 구현법의 대안)
--------------------------------------------------------------------------------------
'''

# gzip 압축
import gzip
with gzip.open('d:\data\somefile.gz', 'rt') as f:
    text = f.read()

# bz2 압축
import bz2
with bz2.open('d:\data\somefile.bz2', 'rt') as f:
    text = f.read()


# 압축한 데이터 사용방법
# gzip 압축
import gzip
with gzip.open('d:\data\somefile.gz', 'wt') as f:
    f.write(text)

# bz2 압축
import bz2
with bz2.open('d:\data\somefile.bz2', 'wt') as f:
    f.write(text)

'''
=> 모든 입출력은 텍스트를 사용하고 유니코드 인코딩/디코딩 수행
   바이너리 데이터를 사용하고 싶다면 rb 또는 wb 모드 사용!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 압축한 데이터를 쓸 때는 compresslevel 인자로 압축 정도를 지정
--------------------------------------------------------------------------------------
'''

with gzip.open('d:\data\somefile.gz', 'wt', compresslevel=5) as f:
    f.write(text)

'''
--------------------------------------------------------------------------------------        
- gzip.open() 과 bz2.open() 을 기존에 열려 있는 바이너리 파일의 상위에 위치시키기
--------------------------------------------------------------------------------------
'''

import gzip

f = open('d:\data\somefile.gz', 'rb')
with gzip.open(f, 'rt') as g:
    text = g.read()





'''
--------------------------------------------------------------------------------------        
5.8 고정 크기 레코드 순환

문제 : 파일을 줄 단위로 순환하지 않고, 크기를 지정해서 그 단위별 순환하고 싶다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------        
- iter() 함수와 functools.partial() 을 사용
--------------------------------------------------------------------------------------
'''

from functools import partial

RECORD_SIZE = 32

with open('d:\data\somefile.txt', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for i in records:
        pass

'''
=> 위 예제는 records 객체는 파일의 마지막에 도달할 때까지 고정 크기 데이터를 생산하는 순환 객체이다
   하지만 파일의 크기가 지정한 크기의 정확한 배수가 아닌 경우 마지막 아이템의 크기가 예상보다 작을 수도 있다
--------------------------------------------------------------------------------------
'''


'''
--------------------------------------------------------------------------------------        
5.11 경로 다루기

문제 : 기본 파일, 이름, 절대 경로 등을 찾기 위해 경로 다루기
--------------------------------------------------------------------------------------
'''


'''
--------------------------------------------------------------------------------------        
- 경로를 다루기 위해서 os.path 모듈의 함수 사용
--------------------------------------------------------------------------------------
'''

import os
path = 'd:\data\sports.csv'

# 경로의 마지막 부분 구하기

print(os.path.basename(path))

# 디렉토리 이름 구하기
print(os.path.dirname(path))

# 각 부분을 합치기
print(os.path.join('tmp', 'data', os.path.basename(path)))

# 사용자의 홈 디렉토리 펼치기
path = 'd:\data\sports.csv'
print(os.path.expanduser(path))

# 파일 확장자 나누기
print(os.path.splitext((path)))

'''
--------------------------------------------------------------------------------------        
- 파일 이름을 다루기 위해서 문자열 관련된 코드를 직접 작성하지 말고 os.path 모듈을 사용해야 한다
  이는 이식성과 어느 정도 관련이 있다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------        
5.12 파일 존재 여부 확인

문제 : 파일이나 디렉터리가 존재하는지 확인해야 한다
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------        
- 파일이나 디렉터리의 존재 여부를 확인하기 위해서 os.path 모듈 사용
--------------------------------------------------------------------------------------
'''

import os

print(os.path.exists('d:\data\sports.csv'))

'''
--------------------------------------------------------------------------------------        
- 파일의 종류 확인(파일이 없는 경우 False 반환)
--------------------------------------------------------------------------------------
'''

import os

# 일반 파일인지 확인
print(os.path.isfile('d:\data\sports.csv'))

# 디렉터리인지 확인
print(os.path.isdir('d:\data\sports.csv'))

# 심볼릭 링크인지 확인
print(os.path.islink('d:\data\sports.csv'))

# 연결된 파일 얻기
print(os.path.realpath('d:\data\sports.csv'))

'''
--------------------------------------------------------------------------------------        
- 메타데이터(파일크기, 수정 날짜) 등이 필요할 때도 os.path 모듈 사용
--------------------------------------------------------------------------------------
'''

import os

print(os.path.getsize('d:\data\sports.csv'))

print(os.path.getctime('d:\data\sports.csv'))


import time

print(time.ctime(os.path.getmtime('d:\data\sports.csv')))

'''
--------------------------------------------------------------------------------------        
- os.path를 사용하면 파일 테스팅은 그리 어렵지 않다 
  유의해야 할 점은 아마도 파일 권한에 관련된 것 뿐
  특히 메터데이터에 접근할 때는 권한에 주의해야 한다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------        
5.13 디렉터리 리스팅 구하기

문제 : 디렉터리나 파일 시스템 내부의 파일 리스트 구하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------        
- os.listdir() 함수로 디렉터리 내에서 파일리스트 얻기
--------------------------------------------------------------------------------------
'''

import os

names = os.listdir('d:\data\\')

print(names)

'''
--------------------------------------------------------------------------------------        
- 만약 데이터를 걸러 내야 한다면 os.path 라이브러리 파일에 리스트 컴프리헨션(list comprehension) 사용
--------------------------------------------------------------------------------------
'''

import os.path

# 일반 파일 모두 구하기
names = [name for name in os.listdir('d:\data\\')
         if os.path.isfile(os.path.join('d:\data\\', name))]

print(names)

# 디렉터리 모두 구하기
dirnames = [name for name in os.listdir('d:\data\\')
            if os.path.isdir(os.path.join('d:\data\\', name))]

print(dirnames)

'''
--------------------------------------------------------------------------------------        
- 문자열의 startswitch() 와 endswith() 메소드를 사용하면 디렉터리의 내용을 걸러 내기 유용
--------------------------------------------------------------------------------------
'''

import os

pyfiles = [name for name in os.listdir('d:\data\\')
           if name.endswith('.py')]

print(pyfiles)

'''
--------------------------------------------------------------------------------------        
- 파일 이름 매칭을 하기 위해 glob 이나 fnmatch 모듈 사용
--------------------------------------------------------------------------------------
'''

import glob

pyfiles = glob.glob('d:\data\\*.py')

print(pyfiles)


from fnmatch import fnmatch

pyfiles = [name for name in os.listdir('d:\data\\')
           if fnmatch(name, '*.py')]

print(pyfiles)

'''
--------------------------------------------------------------------------------------        
- 디렉터리 리스트를 구하기는 쉽지만, 앞에 나온 방법으로는 엔트리의 이름만 얻을 수 있다

- 파일 크기나 수정 날짜 등 메타데이터가 필요하다면 os.path 모듈의 추가적인 함수를 사용하거나 os.stat() 함수 사용
--------------------------------------------------------------------------------------
'''

# 디렉터리 리스트 구하기

import os
import os.path
import glob

pyfiles = glob.glob('*.py')


# 파일 크기와 수정 날짜 구하기
name_sz_date = [(name, os.path.getsize(name), os.path.getmtime(name))
                for name in pyfiles]

for name, size, mtime in name_sz_date:
    print(name, size, mtime)

# 대안 : 파일 메타데이터 구하기
file_metadata = [(name, os.path(name)) for name in pyfiles]

for name, meta in file_metadata:
    print(name, meta.st_size, meta.st_mtime)




















