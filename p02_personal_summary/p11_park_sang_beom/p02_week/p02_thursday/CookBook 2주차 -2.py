'''
--------------------------------------------------------------------------------------
- 3.11 임의의 요소 뽑기

문제 : 시퀀스에서 임의의 아이템을 고르거나 난수 생성 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 시퀀스에서 임의의 아이템을 선택하려면 random.choice() 사용
--------------------------------------------------------------------------------------
'''

import random

values = [1, 2, 3, 4, 5, 6]

print(random.choice(values))
print(random.choice(values))
print(random.choice(values))
print(random.choice(values))

'''
--------------------------------------------------------------------------------------
- 임의의 아이템을 N개 뽑아서 사용하고 버릴 목적이라면 random.sample() 사용
--------------------------------------------------------------------------------------
'''

import random

values = [1, 2, 3, 4, 5, 6]

print(random.sample(values, 2))
print(random.sample(values, 2))
print(random.sample(values, 3))
print(random.sample(values, 3))

'''
--------------------------------------------------------------------------------------
- 단순히 시퀀스의 아이템을 무작위로 섞으려면 random.shuffle() 사용
--------------------------------------------------------------------------------------
'''

import random

values = [1, 2, 3, 4, 5, 6]
random.shuffle(values)

print(values)

'''
--------------------------------------------------------------------------------------
- 임의의 정수를 생성하려면 random.randint() 사용
--------------------------------------------------------------------------------------
'''

import random

print(random.randint(0, 10))

'''
--------------------------------------------------------------------------------------
- 0과 1 사이의 균등 부동 소수점 값을 생성하려면 random.random() 사용
--------------------------------------------------------------------------------------
'''

import random

print(random.random())

'''
--------------------------------------------------------------------------------------
- N비트로 표현된 정수를 만들기 위해서는 random.getrandbits() 사용
--------------------------------------------------------------------------------------
'''

import random

print(random.getrandbits(200))

'''
--------------------------------------------------------------------------------------
- random 모듈은 Mersenne Twister 알고리즘을 사용해 난수를 발생
  이 알고리즘은 정해진 것 이지만 random.seed() 함수로 시드 값 변경 가능
  
- 그외에 기능
--------------------------------------------------------------------------------------
'''

import random

random.seed()               # 시스템 시간이나 os.urandom() 시드
random.seed(12345)          # 주어진 정수형 시드
random.seed(b'bytedata')    # 바이트 데이터 시드

random.uniform()            # 균등 분포 숫자 계산
random.gauss()              # 정규식 분포 숫자 계산





'''
--------------------------------------------------------------------------------------
3.12 시간 단위 변환

문제 : 날짜를 초, 시간을 분 으로 시간 단위 변환 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 단위 변환이나 단위가 다른 값에 대한 계산을 하려면 datetime 모듈 사용
  시간의 간격을 나타내기 위해서는 timedelta 인스턴스 생성
--------------------------------------------------------------------------------------
'''

from datetime import timedelta

a = timedelta(days=2, hours=6)
b = timedelta(hours=4.5)
c = a + b

print(c.days)
print(c.seconds)
print(c.seconds / 3600)
print(c.total_seconds() / 3600)

'''
--------------------------------------------------------------------------------------
- 특정 날짜와 시간을 표현하려면 datetime 인스턴스를 만들고 표준 수학 연산 하기
--------------------------------------------------------------------------------------
'''

from datetime import datetime

a = datetime(2012, 9, 23)
b = datetime(2012, 12, 21)
d = b -a
now = datetime.today()

print(a + timedelta(days=10))
print(d.days)
print(now)
print(now + timedelta(minutes=10))

'''
--------------------------------------------------------------------------------------
- 계산을 할 때는 datetime이 윤년을 인식한다
--------------------------------------------------------------------------------------
'''

from datetime import datetime

a = datetime(2012, 3, 1)
b = datetime(2012, 2, 28)
c = datetime(2013, 3, 1)
d = datetime(2013, 2, 28)

print(a-b)
print((a-b).days)
print((c-d).days)

'''
--------------------------------------------------------------------------------------
- 시간대(time zone)나, 퍼지 시계 범위(fuzzy time range), 공휴일 계산 등의 더욱 복잡한 날짜 계산이
  필요하다면 dateutil 모듈 사용
  
- 대부분의 비슷한 시간 계산은 dateutil.relativedelta() 함수 수행
--------------------------------------------------------------------------------------
'''

from dateutil.relativedelta import relativedelta

a = datetime(2012, 3, 1)
b = datetime(2012, 12, 21)
d = b - a

print(a + relativedelta(months=+1))
print(a + relativedelta(months=+4))
print(d)

d = relativedelta(b, a)

print(d)
print(d.months)
print(d.days)





'''
--------------------------------------------------------------------------------------
3.13 마지막 금요일 날짜 구하기

문제 : 한 주의 마지막에 나타난 날의 날짜를 구하는 일반적인 해결책 만들기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- datetime 모듈의 클래스와 함수 사용
--------------------------------------------------------------------------------------
'''

from datetime import datetime, timedelta

weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday',
            'Friday', 'Saturday', 'Sunday']

def get_previous_byday(dayname, start_date=None):
    if start_date is None:
        start_date = datetime.today()
    day_num = start_date.weekday()
    day_num_target = weekdays.index(dayname)
    days_ago = (7 + day_num - day_num_target) % 7
    if days_ago == 0:
        days_ago = 7
    target_date = start_date - timedelta(days=days_ago)
    return target_date

print(datetime.today())
print(get_previous_byday('Monday'))
print(get_previous_byday('Tuesday'))
print(get_previous_byday('Friday'))

'''
--------------------------------------------------------------------------------------
- 시작 날짜와 목표 날짜를 관련 있는 숫자 위치에 매핑으로 목표 일자가 나타나고 며칠이 지났는지 알기
--------------------------------------------------------------------------------------
'''

from datetime import datetime
from dateutil.relativedelta import relativedelta
from dateutil.rrule import *

d = datetime.now()

print(d)
print(d + relativedelta(weekday=FR))        # 다음 금요일
print(d + relativedelta(weekday=FR(-1)))    # 마지막 금요일





'''
--------------------------------------------------------------------------------------
3.14 현재 달의 날짜 범위 찾기

문제 : 현재 달의 날짜를 순환해야 하는 코드가 있고, 그 날짜 범위를 계산하는 효율적인 방법 필요
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 범위의 시작일자와 마지막 날짜만 계산하고 datetime.timedelta 객체를 사용해서 날짜를 증가
--------------------------------------------------------------------------------------
'''

from datetime import datetime, date, timedelta
import calendar

def get_month_range(start_date=None):
    if start_date is None:
        start_date = date.today().replace(day=1)
        days_in_month = calendar.monthrange(start_date.year, start_date.month)
        end_date = start_date + timedelta(days=days_in_month)
        return(start_date, end_date)

a_day = timedelta(days=1)
first_day, last_day = get_month_range()

while first_day < last_day:
    print(first_day)
    first_day += a_day

'''
=> 첫째 날을 간단히 구하기 위해서 date의 replace() 메소드에 days 속성을 1로 설정
   replace() 메소드는 시작한 것과 동일한 객체를 만든다는 점이 좋다

=> date 인스턴스를 입력하면 그 결과도 date가 된다
   마찬가지로 datetime 인스턴스를 넣으면 datetime 인스턴스를 얻는다
   
=> calendar.monthrange() 함수로 주어진 월에 날짜가 몇 개 있는지 찾는다

=> monthrange()는 월에 포함된 날짜 수와 주의 날짜를 포함한 튜플을 반환하는 유일한 함수수
-------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 발생자(generator)를 사용해서 쉽게 구현
--------------------------------------------------------------------------------------
'''

from datetime import datetime

def date_range(start, stop, step):
    while start < stop:
        yield start
        start += step

for d in date_range(datetime(2012,9,1), datetime(2012,10,1), timedelta(hours=6)):
    print(d)





'''
--------------------------------------------------------------------------------------
3.15 문자열을 시간으로 변환

문제 : 문자열 형식의 시간 데이터를 datetime 객체로 변환하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- datetime 모듈 사용
--------------------------------------------------------------------------------------
'''

from datetime import datetime

text = '2012-09-20'
y = datetime.strptime(text, '%Y-%m-%d')
z = datetime.now()
diff = z - y

print(diff)

'''
=> datetime.strptime() 메소드는 네 자리 연도 표시를 위한 %Y, 두 자리 월 표시를 위한 %m과
   같은 서식 지원
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- datetime 객체 생성 코드
--------------------------------------------------------------------------------------
'''

from datetime import datetime

z = datetime.now()
nice_z = datetime.strftime(z, '%A %B %d, %Y')

print(nice_z)

'''
--------------------------------------------------------------------------------------
- 날짜 형식이 'YYYY-MM-DD' 인 경우 함수 생성
--------------------------------------------------------------------------------------
'''

from datetime import datetime

def parse_ymd(s):
    year_s, mon_s, day_s = s.split('-')
    return datetime(int(year_s), int(mon_s), int(day_s))





'''
--------------------------------------------------------------------------------------
3.16 시간대 관련 날짜 처리

문제 : 시카고 시간으로 2012년 12월 21일 오전 9시 30분에 화상 회의가 예정되어 있다면
      인도의 방가로르에 있는 친구는 몇 시에 회의실에 와야 하나?
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- pytz 모듈(datetime 라이브러리에서 생성한 날짜를 현지화할 때 사용)
--------------------------------------------------------------------------------------
'''

from datetime import datetime
from pytz import timezone

d = datetime(2012, 12, 21, 9, 30, 0)

print(d)

# 시카고에 맞게 현지화
central = timezone('US/Central')
loc_d = central.localize(d)

print(loc_d)

# 방갈로르 시간으로 변환
bang_d = loc_d.astimezone(timezone('Asia/Kolkata'))

print(bang_d)

'''
--------------------------------------------------------------------------------------
- normalize() 메소드(서머타임 고려하기)
  예 : 미국에서 표준 서머타임은 3월 13일 오전 2시에 시작한다(여기서 한시간 생략)
--------------------------------------------------------------------------------------
'''

from datetime import datetime

d = datetime(2013, 3, 13, 1, 45)
central = timezone('US/Central')
loc_d = central.localize(d)
later = central.normalize(loc_d + timedelta(minutes=30))

print(later)





'''
--------------------------------------------------------------------------------------
Chapter 4 이터레이터와 제너레이터
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
4.1 수동으로 이터레이터 소비

문제 : 순환 가능한 아이템에 접근할 때 for 순환문을 사용하지 않기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 수동으로 이터레이터를 소비하려면 next() 함수 사용
  StopIterator 예외 처리하기 위한 코드 
--------------------------------------------------------------------------------------
'''

with open('/etc/passwd') as f:
    try:
        while True:
            line = next(f)
            print(line, end='')
    except StopIteration:
        pass

'''
--------------------------------------------------------------------------------------
- 일반적으로 StopIteration은 순환의 끝을 알리는데 사용한다.
  하지만 next()를 수동으로 사용한다면 None 과 같은 종료 값을 반환하는데 사용할 수도 있다
--------------------------------------------------------------------------------------
'''

with open('/etc/passwd') as f:
    while True:
        line = next(f, None)
        if line is None:
            break
        print(line, end='')





'''
--------------------------------------------------------------------------------------
4.2 델리게이팅 순환

문제 : 리스트, 튜플 등 순환 가능한 객체를 담는 사용자 정의 컨테이너를 만들었다
      이 컨테이너에 사용 가능한 이터레이터 만들기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 일반적으로 컨테이너 순환에 사용할 __iter__() 메소드 정의
--------------------------------------------------------------------------------------
'''

class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

    def __repr__(self):
        return 'Node({!r})'.format(self.value)

    def add_child(self, node):
        self.children.append(node)

    def __iter__(self):
        return iter(self._children)

if __name__ == '__main__':
    root = Node()
    child1 = Node(1)
    child12 = Node(2)
    root.add_child(child1)
    root.add_child(child12)
    for ch in root:
        print(ch)

'''
=> 이 코드에서는 __iter__() 메소드 순환 요청을 _children 속성으로 전달
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 파이썬의 이터레이터 프로토콜은 __iter__() 가 실제 순환을 수행하기 위한 __next__() 메소드를
  구현하는 특별 이터레이터 객체를 반환하기를 요구한다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.3 제너레이터로 새로운 순환 패턴 생성

문제 : 내장 함수(range(), reversed()) 와는 다른 동작을 하는 순환 패턴 만들기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 제너레이터 함수를 사용하여 특정 범위의 부동 소수점 숫자를 만드는 제너레이터 코드
--------------------------------------------------------------------------------------
'''

def frange(start, stop, increment):
    x = start
    while x < stop:
        yield x
        x += increment

for n in frange(0, 4, 0.5):
    print(n)

print(list(frange(0, 1, 0.125)))

'''
--------------------------------------------------------------------------------------
- 내부의 yield 문의 존재로 인해 함수가 제너레이터가 되었다
  동작 원리 코드
--------------------------------------------------------------------------------------
'''

def countdown(n):
    print('Starting to count from', n)
    while n > 0:
        yield n
        n -= 1
    print('Done! ')

# 제너레이터 생성, 아무 출력물이 없다
c = countdown(3)

print(c)

# 값을 만들기 위한 첫 번재 실행
print(next(c))

# 다음 값을 위한 실행
print(next(c))

# 다음 값을 위한 실행
print(next(c))

# 다음 값을 위한 실행(순환 종료)
print(next(c))

'''
=> 제너레이터 함수 순환에 의한 다음 연산에 응답하기 위해서만 실행된다
   제너레이터 함수가 반환되면 순환을 종료한다
--------------------------------------------------------------------------------------
'''





'''
--------------------------------------------------------------------------------------
4.4 이터레이터 프로토콜 구현

문제 : 순환을 지원하는 객체를 만드는데, 이터레이터 프로토콜을 구현하는 쉬운 방법
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 객체에 대한 순환을 가장 쉽게 구현하는 방법은 제너레이터 함수 사용
  노드를 깊이-우선 패턴으로 순환하는 이터레이터 코드
--------------------------------------------------------------------------------------
'''


class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

    def __repr__(self):
        return 'Node({!r})'.format(self.value)

    def add_child(self, node):
        self.children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()

if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child12 = Node(2)
    root.add_child(child1)
    root.add_child(child12)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child1.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)

'''
--------------------------------------------------------------------------------------
- 파이썬의 이터레이터 프로토콜은 __iter__()가 __next__() 메소드를 구현하고 종료를 알리기 위해
  StopIteration 예외를 사용하는 특별 이터레이터 객체를 반환하기를 요구한다
  
- 이터레이터 클래스를 사용한 depth_first() 메소드 코드
--------------------------------------------------------------------------------------
'''

class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

    def __repr__(self):
        return 'Node({!r})'.format(self.value)

    def add_child(self, other_node):
        self.children.append(other_node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        return depthfirstIterator(self)

class DepthFirstInterator(object):
    def __init__(self, start_node):
        self.node = start_node
        self.children_iter = None
        self.child_iter = None

    def __iter__(self):
        return self

    def __next__(self):
        # 막 시작했다면 자신을 반환한다. 자식에 대해서 이터레이터 생성
        if self.children_iter is None:
            self.children_iter = iter(self.node)
            return self.node

        # 자식을 처리 중이라면 다음 아이템을 반환
        elif self.children_iter:
            try:
                nextchild = next(self.children_iter)
                return nextchild
            except StopIteration:
                self.children_iter = None
                return next(self)

        # 다음 자식으로 진행하고 순환 시작
        else:
            self.children_iter = next(self.children_iter).depth_first()
            return next(self)


'''
--------------------------------------------------------------------------------------
4.5 역방향 순환

문제 : 시퀀스 아이템을 역방향으로 순환 하기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 내장 함수 reversed() 사용
--------------------------------------------------------------------------------------
'''

a = [1, 2, 3, 4]

for i in reversed(a):
    print(i)

'''
=> 역방향 순환은 객체가 __reversed__() 특별 메소드를 구현하고 있거나 크기를 알 수 있는
   경우에만 가능!
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- __reversed__() 메소드 구현
--------------------------------------------------------------------------------------
'''

class Countdown:
    def __init__(self, start):
        self.start = start

    # 순방향 순환
    def __iter__(self):
        n = self.start
        while n > 0:
            yield n
            n -= 1

    # 역방향 순환
    def __reversed__(self):
        n = 1
        while n <= self.start:
            yield n
            n += 1





'''
--------------------------------------------------------------------------------------
4.6 추가 상태를 가진 제너레이터 함수 정의

문제 : 제너레이터 함수를 정의하고 싶지만, 사용자에게 노출할 추가적인 상태 넣기
--------------------------------------------------------------------------------------
'''

'''
--------------------------------------------------------------------------------------
- 사용자에게 추가 상태를 노출하는 제너레이터를 원할 때, __iter__() 메소드에 제너레이터 함수
  코드를 넣어서 쉽게 클래스로 구현
--------------------------------------------------------------------------------------
'''

from collections import deque

class linehistory:
    def __init__(self, lines, hislen=3):
        self.lines = lines
        self.history = deque(maxlen=hislen)

    def __iter__(self):
        for lineno, line in enumerate(self.lines, 1):
            self.history.append((lineno, line))
            yield line

    def clear(self):
        self.history.clear()

'''
=> 이 클래스를 사용하려면 일반 제너레이터 함수처럼 대해야 한다.
   하지만 인스턴스를 만들기 때문에 history() 속성이나 clear() 메소드 같은 내부 속성에 접근
--------------------------------------------------------------------------------------
'''

